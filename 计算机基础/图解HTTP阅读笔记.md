# 1. 了解Web及网络基础

## 1.1 使用HTTP协议访问Web

1. 客户端：发送请求获取服务器资源的Web浏览器。

## 1.2 HTTP的诞生

### 1.2.1 为知识共享而规划Web

### 1.2.2 Web成长时代

### 1.2.3 驻足不前的HTTP

## 1.3 网络基础TCP/IP

1. 通常使用的网络实在TCP/IP协议族的基础上运作的，而HTTP属于他内部的一个子集。

### 1.3.1 TCP/IP协议族

1. **协议**：如何探测到通信目标、由哪一边发起通信、使用哪种语言进行通信、怎样结束通信等规则。

### 1.3.2 TCP/IP的分层管理

1. TCP/IP协议族按层次分别为：应用层、传输层】网络层、数据链路层。
    1. 层次化的好处：1）某个地方需要改动设计，只需要把变动的层改变。各层的接口规划好之后无需变化。2）设计也变得简单了，各层只考虑本层次的实现和任务。
2. **应用层**：决定了向用户提供应用服务时通信的活动。e.g.FTP（文件传输协议）和DNS（域名系统）服务就是其中两类。HTTP协议也处于该层次。
3. **传输层**：对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。有两个性质不同的协议：TCP传输控制协议和UDP用户数据报协议。
4. **网络层**：用来处理在网络上流动的数据包。数据包时网络传输最小数据单位。该层规定通过怎样的路径到达对方的计算机，并把数据包传送给对方。
5. **链路层**：用来处理网络的硬件部分，包括控制操作系统、硬件的设备驱动、NIC（网卡），及光纤等物理可见部分。

### 1.3.3 TCP/IP通信传输流

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202231519267.png" alt="image-20220223151945054" style="zoom:30%;" />

* 我们用HTTP举例来说明，首先作为发送端的客户端在应用层（HTTP协议）发出一个想看某个Web页面的HTTP请求。
* 接着，为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。
* 在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。
* 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202231521523.png" alt="image-20220223152100487" style="zoom:33%;" />

这种将数据信息包装起来的做法称为**封装**。

## 1.4 与HTTP关系密切的协议：IP、TCP和DNS

### 1.4.1 负责传输的IP协议

1. IP网际协议位于网络层。它的作用时把各种数据包传送给对方，而要确保确实传送到对方，则需要满足各类条件，最重要两个就是IP地址和MAC地址。

2. 使用ARP协议凭借MAC地址通信

    IP间的通信依赖于MAC地址，网络上通信是经过多个计算机和网络设备中转连接到对方。中转时会利用下一站中转设备的MAC地址来搜索下一个中转目标。ARP是一种用于解析地址的协议，根据同新方的IP反查出对应的MAC地址。

3. **路由选择**：在到达目的地之前，计算机和路由器等设备智能获悉很粗略的传输路线。

### 1.4.2 确保可靠性的TCP协议

1. 按层次分，TCP位于传输层，提供可靠的字节流服务。

    1. 字节流服务：为了方便传输将大块数据分割成为报文段为单位的数据包进行管理。
    2. 可靠的传输服务：把数据准确可靠的传给对方。

2. 确保能达到目标

    1. **三次握手**

    ![image-20220224080416108](https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240804211.png)

## 1.5 负责域名解析的DNS服务

位于应用层的协议，提供域名到IP地址之间的解析服务。

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240806319.png" alt="image-20220224080627277" style="zoom:50%;" />

## 1.6 各种协议和HTTP协议的关系

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240808881.png" alt="image-20220224080809840" style="zoom:33%;" />

## 1.7 URI和URL

### 1.7.1 统一资源标识符URI

由某个协议方案表示的资源的定位标识符。协议方案是指访问资源使用的协议类型名称。

### 1.7.2 URI格式

1. 绝对URI的格式

    <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240811386.png" alt="image-20220224081136345" style="zoom:50%;" />

# 2. 简单的HTTP协议

## 2.1 HTTP协议用于客户端和服务端之间的通信

必然有一个客户端，一个服务端

## 2.2 通过请求和响应的交换达成通信

1. 首先从客户端开始建立通信。

2. 请求报文是有请求方法、请求URI、协议版本、可选的请求首部字段和内容实体组成。

    <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240816818.png" alt="image-20220224081643777" style="zoom:50%;" />

3. 接到请求的服务器会将请求内容的处理结果以相应的形式返回。响应报文基本上由协议版本、状态吗（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可短的响应首部字段以及实体主体构成。

    <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240819451.png" alt="image-20220224081923412" style="zoom:50%;" />

## 2.3 HTTP是不保存状态的协议

1. 不保留之前的请求或者响应报文的信息。这是为了更快的处理大量食物，确保协议的可伸缩性，而特意设计成如此简单。
2. 如果期望保持状态功能，引入了Cookie技术。

## 2.4 请求URI定位资源

1. 当客户端请求访问资源发送请求时， URI需要将作为请求报文中的请求URI包含在内。
2. 如果不是访问特定资源，而是对服务器本身发起请求，可以用*来歹意请求URI。e.g.查询HTTp服务器支持的HTTP方法种类：```OPTIONS * HTTP/1.1```

## 2.5 告知服务器意图的HTTP方法

1. GET：获取资源

    1. GET用来请求访问已被URI识别的资源。如果访问的是文本，那就保持原样返回，如果是CGI（通用网关接口），则返回经过执行后的输出结果。

    2. e.g. 

        <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240829525.png" alt="image-20220224082938482" style="zoom:40%;" />

2. POST：传输实体主体

    ![image-20220224083307695](https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240833744.png)

3. PUT：传输文件

    1. 在请求报文的主体包含文件内容，保存到请求URI指定的位置。

    2. 自身不带验证机制，存在安全性问题。

        ![image-20220224083749879](https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240837923.png)

4. HEAD：获得报文首部

    和GET方法一样，只是不返回报文主体。用于确认URI的有效性及资源更新的日期时间等。

    ![image-20220224084138490](https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240841535.png)

5. DELETE：删除文件

    与PUT相反。不带验证机制，存在安全问题。

    ![image-20220224084232162](https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240842205.png)

6. OPTIONS：询问支持方法

    用来查询针对请求URI指定的资源支持的方法。

    <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240843054.png" alt="image-20220224084314011" style="zoom:50%;" />

7. TRACE：追寻路径

    此方法时让Web服务器将之前的请求通信环回给客户端的方法。确认链接过程中发生的一系列操作：发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200 OK的响应。也存在安全性问题（XST）。

    ![image-20220224084557638](https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240845678.png)

​		<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240846834.png" alt="image-20220224084607794" style="zoom:50%;" />

8. CONNECT：要求用隧道协议链接代理

    要求与代理服务器通信时建立隧道。主要是用SSL和TLS把通信内容加密后经网络隧道传输。

    ![image-20220224084803484](https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240848528.png)

    ![](https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240848715.png)

## 2.6 使用方法下达命令

向请求URI指定的资源发送请求报文时，采用称为**方法**的命令。

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202240850665.png" alt="image-20220224085008623" style="zoom:50%;" />

## 2.7 持久连接节省通信量

### 2.7.1 持久连接

1. 反复断开和连接增加通信量的消耗。
2. 持久连接：特点是只要任意一端没有明确提出断开连接，则保持TCP连接状态。

### 2.7.2 管线化

不用等待响应就可以直接发送下一个请求。

## 2.8 使用Cookie的状态管理

通过在请求和响应报文中写入Cookie信息来控制客户端的状态。

Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。

服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

# HTTP报文内的HTTP信息

## 3.1 HTTP报文

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202241538518.png" alt="image-20220224153840460" style="zoom:50%;" />

## 3.2 请求报文和响应报文的结构

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202202241539576.png" alt="image-20220224153940529" style="zoom:50%;" />

## 3.3 编码提升传输速率

### 3.3.1 报文主体和实体主体的差异

1. 报文：是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输。
2. 实体：作为请求或相应的有效载荷数据被传输，其内容由实体首部和实体主体组成。
3. 通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。

### 3.3.2 压缩传输内容的编码

常用的内容编码有以下几种。gzip（GNU zip）、compress（UNIX系统的标准压缩）、defate（zlib）、identity（不进行编码）

### 3.3.3 分割发送的分块传输编码

1. **分块传输编码**：在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked TransferCoding）。

## 3.4 发送多种数据的多部分对象集合

HTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。

## 3.5 获取部分内容的范围请求

1. 当网络中断，大文件的传输中断，为了解决从中断处恢复下载，有了范围请求，可以**指定下载的实体范围**。
2. 针对范围请求，响应会返回状态码为206 Partial Content的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart/byteranges后返回响应报文。
3. 如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。

## 3.6 内容协商返回最合适的内容

1. 当浏览器的默认语言为英语或中文，访问相同URI的Web页面时，则会显示对应的英语版或中文版的Web页面。这样的机制称为**内容协商**（Content Negotiation）。
2. 内容协商技术有以下3种类型。
    1. 服务器驱动协商（Server-driven Negotiation）由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。
    2. 客户端驱动协商（Agent-driven Negotiation）由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用JavaScript脚本在Web页面上自动进行上述选择。比如按OS的类型或浏览器类型，自行切换成PC版页面或手机版页面。
    3. 透明协商（Transparent Negotiation）是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。

# 4. 返回结果的HTTP状态码

## 4.1 状态码告知从服务端返回的请求结果

状态码的指责是当客户端向服务端发送请求时，描述返回的请求结果。

## 4.2 2xx 成功

### 4.2.1 200 OK

表示从客户端发来的请求在服务端被正常处理了。

### 4.2.2 204 No Content

1. 该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。
2. 一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。

### 4.2.3 206 Partial Content

该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。

## 4.3 3xx重定向

### 4.3.1 301 Moved Permanently

永久重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI

### 4.3.2 302 Found

临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问

### 4.3.3 303 See Other

该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。

### 4.3.4 304 Not Modified

该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304 NotModified

### 4.3.5 307 Temporary Redirect

临时重定向。该状态码与302 Found有着相同的含义。

## 4.4 4xx客户端错误

### 4.4.1 400 Bad Request

该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200 OK一样对待该状态码。

### 4.4.2 401 Unauthorized

该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。

### 4.4.3 403 Forbidden

该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。

### 4.4.4 404 Not Found

该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用

## 4.5 5xx服务器错误

### 4.5.1 500 Internal Server Error

该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。

### 4.5.2 503 Service Unavailable

该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

# 5. 与HTTP协作的Web服务器

## 5.1 用单台虚拟主机实现多个域名

域名通过DNS服务映射到IP地址之后访问目标网站，当请求发送到服务器时，已经是IP地址了。所以，如果一台服务器内托管了www.tricorder.jp和www.hackr.jp这两个域名，当收到请求时就需要弄清楚究竟要访问哪个域名。在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。

## 5.2 通信数据转发程序：代理、网关、隧道

### 5.2.1 代理

代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。

1. 代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。
2. 缓存代理代理转发响应时，缓存代理（CachingProxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。
3. 透明代理转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（TransparentProxy）。反之，对报文内容进行加工的代理被称为非透明代理。

### 5.2.2 网关

网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非HTTP协议服务。

### 5.2.3 隧道

隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。

## 5.3 保存资源的缓存

1. 缓存是指代理服务器或客户端本地磁盘内保存的资源副本
2. 缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。

### 5.3.1 缓存的有效期限

### 5.3.2 客户端的缓存

# 6. HTTP首部

