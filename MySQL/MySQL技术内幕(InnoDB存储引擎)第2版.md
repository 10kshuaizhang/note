# 第一章 MySQL体系结构和存储引擎

## 1.1 定义数据库和实例

1. **数据库**：物理操作系统文件和其他形式<u>文件</u>类型的<u>集合</u>
2. **实例**：MySQL数据由后台<u>线程</u>以及一个共享内存区组成。
    * 共享内存可以背运行的后台线程所共享
    * 数据库实例才是真正用于操作数据库文件的。
3. MySQL数据库实例在系统上的表现就是一个进程。

## 1.2 MySQL体系结构

1. MySQL由以下部分组成：
    1. 连接池组件
    2. 管理服务和工具组件
    3. SQL接口组件
    4. 查询分析器组件
    5. 优化器组件
    6. 缓冲组件
    7. 插件式存储引擎
    8. 物理文件
2. **插件式表存储引擎**：区别于其他数据库最重要的一个特点。
3. 存储引擎是基于表的。

## 1.3 MySQL存储引擎

### 1.3.1 InnoDB存储引擎

1. 特点：行锁支持，支持外键，支持非锁定读。
2. 高并发性通过多版本并发控制MVCC来获得，并实现了SQL 标准的4种隔离级别，<u>默认为REPEATABLE级别</u>。同时使用next-key locking的侧罗来避免幻读（phantom）的产生。
    1. 另外还提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能高可用的功能
3. 对于数据的存储，innoDB采用聚集的方式，因此每张表的存储都是按主键的顺序进行存放。
    * 如果没有显示定义主键，存储引擎会为每一行商城一个6字节的ROWID并以此作为主键。

### 1.3.2 MyISAM存储引擎

1. 特点：不支持事务、表锁设计，支持全文索引；缓冲池只缓存索引文件，而不缓冲数据文件。
2. myISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。

### 1.3.3 NDB存储引擎

1. 集群存储引擎，share nothing的集群架构。特点是数据全部放在内存，因此主键查找的速度极快。

### 1.3.4 Memory存储引擎

1. 将数据都放在内存中，适合存储临时数据表，以及数据仓库的维度表。默认使用哈希索引而非B+树索引。
2. 只支持表锁，并发性能差，不支持TEXT和BLOB类型；存储变长字段（varchar）是按照定长字段（char）进行的，因此会浪费内存。
3. 如果用它存放查询的中间结果，且结果大于表容量，则数据库会把它转换到MyISAM存储引擎表而存放到磁盘中，又myISAM不缓存数据文件，这时产生的临时表的性能对查询会有损失。

### 1.3.5 Archive存储引擎

1. 只支持INSERT和SELECT操作
2. 提供告诉的插入和压缩功能，适合存储归档数据。

### 1.3.6 Federated存储引擎

1. 不存放数据，指向一台远程MySQL数据库服务器上的表，类似透明网关。

### 1.3.7 Maria存储引擎

1. MyISAM后续版本替代，支持缓存数据和索引文件，应用了行锁设计，提供了MVCC，支持事务和非事务的选项，以及更好处理BLOB的性能。

### 1.3.8 其他存储引擎

## 1.4 存储引擎的比较（略）

## 1.5 连接MySQL

### 1.5.1 TCP/IP

### 1.5.2 命名管道和共享内存

### 1.5.3 UNIX域套接字

## 1.6 小结

本章介绍了数据库和数据库实例的定义，分析了MySQL数据库体系结构，进一步突出强调实例和数据库的区别。介绍了各种常见表存储引擎的特性、使用情况以及它们之间的区别。

# 第二章 InnoDB存储引擎

本章介绍InnoDB体系架构以及其特性。

## 2.1 InnoDB存储引擎概述

## 2.2 InnoDB存储引擎的版本

## 2.3 InnoDB体系架构

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202112271745677.png" alt="image-20211227174547457" style="zoom:30%;" />

### 2.3.1 后台线程

1. **Master Thread**： 负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。
2. **IO Thread**： 处理异步IO请求的回调。
    * write，read，log， insert buffer IO Thread
3. **Purge Thread**：将提交的事务的undolog回收。
4. **Purge Cleaner Thread**：将之前版本中的脏页的刷新操作都放到单独的线程来完成。为了减轻原Master Thread的工作以及对于用户查询线程的阻塞。

### 2.3.3 内存

1. **缓冲池**

    1. 因为InnoDB是基于磁盘系统的，并将其中的记录按照页的方式进行管理，可将其视为基于磁盘的数据库系统。由于CPU速度和磁盘速度的鸿沟，通常使用缓冲池技术。
    2. 一块内存区域
        1. 读：先将磁盘读取到的页存放在缓冲池中，下次再读相同页时，先判断是否在缓冲池中，若在，则称命中，直接读取，否则读取磁盘中的页。
        2. 修改：首先修改缓冲池中的页，再以一定的频率刷新到磁盘上。通过一种叫**<u>checkpoint</u>**的机制刷新回磁盘。
    3. 缓冲池的大小影响着数据库的整体性能。
    4. InnoDB存储引擎内存结构
        1. <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202112271817544.png" alt="image-20211227181733510" style="zoom:30%;" />

    5. 从InnoDB 1.0.x开始，允许有多个缓冲池实例，每个页根据哈希平均分配到不同的缓冲池实例中，减少数据库内部的资源竞争。

2. **LRU list、Free List和Flush List**

    1. 缓冲池是通过LRU算法管理的。
        1. InnoDB还有midpoint优化。新读取的页不放在首部而是放入到LRU列表的midpoint位置。默认位置为5/8处。
        2. 相比于朴素LRU算法：某些操作可能将缓冲池的页刷出，影响效率，例如索引或数据的扫描操作，需要访问表中的很多页，这些数据并非热点数据。
        3. 为了解决这个问题，还有一个参数innodb_old_blocks_time，用于表示读取到的mid位置后需要等待多久才会被加入到LRU的热端，如果在执行操作前用户觉得自己的热点数据不止某个值，可以在执行前通过设定此参数使数据尽量不被刷出。
        4. page made young：从old部分加入到new部分的操作。显示了LRU列表中页移动到前端的次数。
        5. LRU列表中的页被修改后成为脏页。
    2. FLUSH列表即为脏列表，脏页存在于FLUSH列表和LUR列表，但是互不影响。LRU列表管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘。

3. 重做日志缓冲：存储引擎现将redo log放在这个缓冲区，然后按照一定频率刷新到redo log 文件。

    1. 刷新时机
        1. Master Thread每一秒
        2. 每个事务提交时
        3. 当redo log缓冲池剩余空间小于一半

4. 额外的内存池

    1. 对内存的管理是通过内存堆。
    2. e.g.缓冲池的缓冲控制对象就是从额外的内存池申请。

## 2.4 checkpoint 技术

1. 为了避免发生数据丢失，当前事务数据库系统普遍采用Arite Ahead Log策略，即当事务提交时，先写重做日志，再修改页。当发生数据丢失时，通过redo log完成数据的恢复。这也是ACID中的D持久性的要求。

2. 如果

    1. 缓冲池可以缓存数据库中所有数据；
    2. 重做日志可以无限增大

    可以通过重做日志来恢复整个数据库中的数据到宕机发生的时刻。

3. **检查点Checkpoint**技术是解决：

    1. 缩短数据库恢复时间
        * 宕机发生时，数据库不需要重做所有的日志，因为checkpoint之前的页都已经刷新回磁盘。数据库只需要对checkpoint之后的重做日志进行恢复。
    2. 缓冲池不够用时，将脏页刷新到磁盘
        * 根据LRU算法算出的最近最少使用的页，如果是脏页，则需要强制执行checkpoint，将脏页刷回磁盘。
    3. 重做日志不可用时，刷新脏页。
        * 出现不可用是因为redo log被设计成重复使用，如果可能发生宕机系统恢复还需要这部分日志，则强制产生checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。

4. InnoDB是通过LSN标记版本的

5. checkpoint分类

    1. Sharp Checkpoint：数据库关闭时所有的脏页都刷新回磁盘。
    2. Fuzzy Checkpoint：只刷新一部分脏页。
        1. Master Thread Checkpoint：异步操作。
        2. FLUSH_LRU_LIST Checkpoint：存储引擎需要保证有100个空闲页可用，会将LRU列表尾部的页移除，如果存在脏页则需要进行checkpoint。
        3. Async/Sync Flush Checkpoint： 指的是重做日志不可用的情况。脏页是从脏页列表选取的。
            1. 在InnoDB 1.2.x版本开始，这部分操作放在了单独的page cleaner Thread中，不会阻塞用户查询线程。
        4. Dirty Page too much Checkpoint：保证缓冲池有足够可用的页。

## 2.5 Master Thread工作方式

### 2.5.1 InnoDB 1.0.x版本之前的Master Thread

1. Master Thread具有最高的线程优先级别
2. 内部由多个循环组成：主循环、后台循环、刷新循环、暂停循环。主线程会跟进数据库运行状态在这几个循环之间切换。
3. Loop被称为主循环，其中有两大部分的操作：每秒钟和每10s。通过thread sleep实现，所以操作是不精确的。
    1. 每秒钟的操作：
        * 日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）；
            * 这个可以解释很大的事务commit时间很短
        * 合并插入缓存（可能）；
            * 当前1s的IO小于5次才会
        * 至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）；
            * 缓冲池中的脏页的比例超过了阈值
        * 如果当前没有用户活动，则切换到background loop（可能）；
4. 后台循环：若当前没有用户活动或者数据库关闭，就会切换到这个循环

### 2.5.2  InnoDB 1.2.x版本之前的Master Thread

1. 从之前的版本看，在写密集的应用程序中，美妙可能会产生大于100个脏页，大于20个插入缓冲。所以InnoDB Plugin提供了innodb_io_capacity来进行控制。
2. 脏页站缓冲池90%太大了。经过测试，默认值变为75%。

### 2.5.3  InnoDB 1.2.x版本的Master Thread

1. 刷新脏页的操作分离到purge cleaner线程

## 2.6 InnoDB 关键特性

* 插入缓冲
* 两次血
* 自适应哈希索引
* 异步IO
* 刷新临接页

### 2.6.1 插入缓冲

1. Insert Buffer：对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引是否在缓冲池中，若在直接插入，若不在则先放入到一个Insert Buffer对象中。好像这个非聚集索引已经插入到叶子结点，实际没有，只是放在另一个位置。然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的合并操作。
    1. 将多个插入合并到一个操作（因为在一个索引页），提高了非聚集索引插入的性能
2. 需要满足的条件
    1. 索引是辅助索引
    2. 索引不是唯一的
3. 问题：写密集情况下插入缓冲会占用过多的缓冲池内存。

4. change Buffer：insert buffer升级版本，对INSERT，DELETE，UPDATE都缓冲
    1. 对一条记录的UPDATE分为两个过程
        1. 将记录标为已删除
        2. 真正将记录删除
5. insert buffer内部实现
    1. b+树
6. Merge Insert buffer

### 2.6.2 两次写

1. 在应用重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做。

### 2.6.3 自适应哈希索引

1. InnoDB会监控对表上各索引的查询，如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引。
    1. 要求：对页的连续访问模式是一致的。
    2. 只能进行等值的查询。

### 2.6.4 异步IO

1. 用户在发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后等待所有的IO操作完成。
2. 可以进行IO merge，将多个IO合并为1个。e.g. 用户需要访问页（space，page_np)为：（8，6）、（8，7）、（8，8），每个页的大小为16KB，同步IO需要进行3次IO操作，AIO会判断到这三个页是连续的，底层会发送一个IO请求从（8，6）开始读取48KB的页。
3. 应用：read ahead，脏页刷新，即磁盘的写入都是由AIO完成。

### 2.6.5 刷新邻接页

1. 刷新脏页时，检测他所在的extent区的所有页，如果是脏页，一起刷新，

## 2.7 启动、关闭与恢复

## 2.8 小结

本章对InnoDB存储引擎及其体系结构（后台线程、内存结构）进行概述，又详细介绍其关键特性，最后介绍启动关闭时一些参数配置。

# 第三章 文件

* 参数文件
* 日志文件
* socket文件
* pid文件
* MySQL表结构文件
* 存储引擎文件

## 3.1 参数文件

### 3.1.1 什么是参数

1. 键值对

### 3.1.2 参数类型

1. 动态参数：实例运行中更改
2. 静态参数：运行生命周期内不可更改

## 3.2 日志文件

* 错误日志
* 二进制日志
* 慢查询日志
* 查询日志

### 3.2.1 错误日志

1. 对MySQL的启动、运行、关闭过程进行了记录。

### 3.2.2 慢查询日志

1. 帮助DBA定位可能存在问题的SQL语句。e.g.设定一个阈值，超过这个阈值的语句都被记录到慢查询日志。
2. 默认是关闭的。

### 3.2.3 查询日志

1. 查询日志记录了所有对MySQL数据库请求的信息，无论是否正确执行。

### 3.2.4 二进制日志

1. 二进制日志记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作。
2. 作用：
    1. 恢复
    2. 复制
    3. 审计

## 3.3 套接字文件

* 在UNIX系统下连接MySQL采用UNIX域套接字方式，需要套接字文件。

## 3.4 pid文件

* 当MySQL实例启动时，会将自己的进程ID写入一个文件中。

## 3.5 表结构定义文件

* 文本格式，视图的定义也在其中。

## 3.6 InnoDB存储引擎文件

### 3.6.1 表空间文件

1. InnoDB采用将存储的数据按<u>**表空间**</u>进行存放的设计。

### 3.6.2 重做日志文件

1. 记录了存储引擎的事务日志。

## 3.7 小结

* 本章介绍MySQL数据库相关的一些文件，可以分为MySQL数据库文件以及各存储引擎相关的文件。与MySQL有关的文件中，**<u>错误文件</u>**和**<u>二进制文件</u>**非常重要。DBA可以使用错误文件的记录来分析错误，也可以通过其警告优化数据库或存储引擎。
* 二进制文件非常关键，可以用来point in time的恢复和复制环境的搭建。
* 最后介绍InnoDB存储引擎相关文件，包括表空间文件和重做日志文件，表空间文件时用来管理存储引擎的存储，分为共享表空间和独立表空间。重做日志非常重要，是存储引擎的事务日志。

# 第四章 表

## 4.1 索引组织表

1. InnoDB中，表都是根据主键顺序组织存放的，这种方式成为索引组织表。
2. InnoDB每个表都有主键，如果创建时没有显式定义
    1. 如果表中存在非空唯一索引，该索引即为主键；若果有多个，则选择第一个定义的；
    2. 否则创建6字节大小的指针

## 4.2 InnoDB逻辑存储结构

* 所有数据都被逻辑的存放在一个空间中，称之为表空间。表空间又由段、区、页组成。页在一些文档也称为块。
* <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202112311511179.png" alt="image-20211231151101069" style="zoom:30%;" />

### 4.2.1 表空间

1. 默认情况下InnoDB有一个共享表空间ibddata1，所有的数据都放在这里；如果用户启用参数innodb_file_per_table，则每张表内的数据可以单独放到一个表空间
    1. 注意：启用参数后，每张表空间只存放数据、索引、插入换台Bitmap页，其他数据如回滚undo信息，插入缓冲索引页、系统事务信息、二次写缓冲还是放在原来的共享表空间。

### 4.2.2 段

### 4.2.3 区

### 4.2.4 页（块）

1. 是InnoDB磁盘管理的最小单位

### 4.2.5 行

## 4.3 InnoDB 行记录格式

### 4.3.1 Compact行记录格式

1. 目的是为了高效的存储数据。

### 4.3.2 Redundant行记录格式

1. 是MySQL5.0之前的行记录方式，而了兼容之前版本的页格式。

### 4.3.3 行溢出数据

1. 一般情况下，InnoDB存储引擎的数据都是存放在页类型为B-tree node中，当发生行溢出时，数据存放在页类型为Uncompress BLOB页中。

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202112311545777.png" alt="image-20211231154548715" style="zoom:33%;" />

### 4.3.4 Compressed和Dynamic行记录格式

### 4.3.5 CHAR的行存储结构

1. 在多字节字符集情况下，CHAR和VARCHAR时机行存储基本是没有区别的。

## 4.4 InnoDB数据页结构

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202112311555725.png" alt="image-20211231155514679" style="zoom:33%;" />

## 4.5 Named File Formats机制

1. 处理不同版本下页结构兼容问题。

## 4.6 约束

### 4.6.1 数据完整性

1. 实体完整性保证表中有一个主键；
2. 域完整性保证每列数据的值满足特定的条件。
    1. 合适的数据类型
    2. 外键约束
    3. 触发器
    4. DEFAULT约束
3. 参照完整性保证两张表之间关系：外键或触发器

### 4.6.2 约束的创建和查找

1. 创建
    1. 表建立时进行定义
    2. ALERT TABLE进行创建

### 4.6.3 约束和索引的区别

* 约束更是一个逻辑的概念，保证数据的完整性；而索引是一个数据结构，既有逻辑上的概念，在数据库中还代表着物理存储方式。

### 4.6.4 对错误数据的约束

### 4.6.5 ENUM和SET约束

### 4.6.6 触发器与约束

1. 触发器的作用时在INSERT、DELETE、UPDATE命令之前或之后自动调用SQL命令或存储过程。

### 4.6.7 外键约束

## 4.7 视图

* 是一个命名的虚表，由一个SQL查询来定义，可以当做表使用。与持久表不同，视图中的数据没有实际的物理存储。

### 4.7.1 视图的作用

1. 被用作一个抽象装置，成需不需要关系基表的结构，只需要按照视图定义来获取或者更新数据。在一定程度上是一个安全层的作用。
2. 也可以通过视图的定义更新基本表。

### 4.7.2 物化视图

1. 用于预先计算并保存多表链接或聚集等耗时较多的SQL操作结果在存储设备上。

## 4.8 分区表（Skip）

## 4.9 小结

* 首先介绍了InnoDB存储引擎表总是按照主键索引顺序存放， 然后深入介绍表的物理实现。
* 接着介绍了表有关的约束问题，MySQL通过约束保证数据的各种完整性，也提到了外键特性。
* 之后介绍了视图，MySQL视图是虚拟表，本身不支持物化视图，但是通过一些技巧（触发器）可以实现一些简单的物化视图功能。
* 最后介绍分区。

# 第五章 索引与算法

## 5.1 InnoDB存储引擎索引概述

1. InnoDB支持常见的索引：
    1. B+树索引：只能查到具体的页，不能到行。把页读入到内存中进行查找。
    2. 全文索引
    3. 哈希索引：自适应

## 5.2 数据结构与算法

### 5.2.1 二分查找法

### 5.2.2 二叉查找树与平衡二叉树

## 5.3 B+树

1. 定义：是为磁盘或其他直接存取辅助设备设计的一种平衡查找树。所有记录节点都是按照键值的大小顺序存放在同一层叶子结点上，由各叶子结点指针进行连接。

    ### 5.3.1 B+树的插入操作

    1. 插入必须保证插入后叶子结点中的记录依然排序，同时要考虑到B+树的三种情况。

        <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201041447898.png" alt="image-20220104144700825" style="zoom:33%;" />

    2. e.g. 

        1. 插入28，满足第一种情况，直接插入即可
            1. <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201041505008.png" alt="image-20220104150526968" style="zoom:33%;" />

        2. 插入70，满足第二种情况，Leaf Page已满，Index Page没有满。插入Leaf Page后情况为50、55、60、65、70，并根据中间值60拆分叶子结点。
            1. <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201041508069.png" alt="image-20220104150828030" style="zoom:33%;" />

        3. 插入95，Leaf Page 和Index Page都满了，符合第三种情况，需要做两次拆分，如下图：
            1. <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201041509605.png" alt="image-20220104150934568" style="zoom:33%;" />

    3. 为了保持平衡会对于新插入的键值做很多的**<u>拆分页</u>**工作，而B+树主要用于磁盘，所以拆分页都是磁盘操作，应该减少。所以，B+树还提供了类似平衡二叉树的**<u>旋转</u>**操作。
        1. 旋转发生在Leaf Page已经满，但是其左右兄弟结点没有满的情况下。B+树会将记录转移到兄弟结点上。通常首先是左兄弟。图5-7插入70的情况：
            1. <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201041515647.png" alt="image-20220104151527593" style="zoom:33%;" />

### 5.3.2 B+树的删除操作

1. B+树使用填充因子控制树的产出变化，50%是可设的最小值。删除操作需要保证删除后叶子结点有序，也需要考虑三种情况：
    1. <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201041519899.png" alt="image-20220104151907858" style="zoom:33%;" />

2. e.g. 根据图5-9的B+树进行操作。首先删除70这个记录，符合第一种情况：

    1. <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201041523932.png" alt="image-20220104152313894" style="zoom:33%;" />

    2. 接着删除25的记录，符合第一种情况，但是25还是Index Page的值，所以删除25后会将28更新到Page Index中：
        1. <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201041525581.png" alt="image-20220104152550545" style="zoom:33%;" />

    3. 最后删除60，删除后填充因子小于50%，需要合并操作。
        1. <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201041530212.png" alt="image-20220104153018176" style="zoom:33%;" />

## 5.4 B+树索引

1. B+树的高度一般在2-4层。
2. 分为聚集索引和辅助索引。区别在于叶子结点是否存放一整行信息。

### 5.4.1 聚集索引

1. InnoDB是索引组织表，表中数据按照主键顺序存放。而聚集索引就是按照每张表主键构造一棵B+树，同时叶子结点存放整张表的行记录数据。所以数据也是索引的一部分。
    1. 索引上直接找到数据，速度快
    2. 因为采用**<u>逻辑</u>**顺序（页和页的记录都是通过**<u>双向链表</u>**连接），适合范围查找。

### 5.4.2 辅助索引（非聚集索引）

1. 叶子结点不包含记录的全部数据，包含键值和书签，书签用来告诉InnoDB哪里可以找到对应的数据。由于InnoDB是索引组织表，所以InnoDB的书签就是相应数据的聚集索引键
2. 当通过辅助索引来寻找数据时，InnoDB会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。

### 5.4.3 B+树索引的分裂

1. InnoDB可以通过插入的顺序信息决定后续插入的分裂方向以及分裂点。

### 5.4.4 B+树索引的管理

#### 1. 索引管理

1. ALTER TABLE... or CREATE/DELETE INDEX ...

#### 2. Fast Index Creation（FIC）

1. 限于辅助索引，对创建索引的表加S锁，创建过程不需要新建表，所以很快
2. 删除过程只需要更新内部视图，将辅助索引空间标为可用，并删除内部视图的对该表的索引定义即可。

#### 3. Online Schema Change

1. 在事务创建过程中可以对表进行读写。

#### 4. Online DDL

1. 创建索引时运行DML操作（INSERT、UPDATE、DELETE）

## 5.5 Cardinality 值

### 5.5.1 什么是Cardinality

1. 在访问表中很少一部分时使用B+树索引才有意义。e.g. 在性别字段，可取范围很小，称为低选择性。添加索引没有必要。如果某个<u>**字段取值范围很广**</u>，几乎没有重复，称为高选择性，此时使用b+树索引比较合适。
2. 如何确定高选择性——cardinality
    1. Cardinality：表示索引中不重复记录数量的<u>预估值</u>。

### 5.5.2 InnoDB存储引擎的Cardinality统计

1. MySQL有不同的存储引擎，每种存储引擎对于B+树索引的实现不同，所以对Cardinality的统计是放在存储引擎层进行的。
2. 由于有可能数据量很大，所以通过**<u>采样</u>**的方式完成。随机取8个叶子结点不同值的平均数。（因为随机，所以每次Cardinality值可能不一样）
3. 发生时机：INSERT和UPDATE，更新策略为如下的某一种：
    1. 表中1/16的数据已发生过变化
    2. stat_modified_counter > 2000000000

## 5.6 B+树索引的使用

### 5.6.1 不同应用中B+树索引的使用

* OLTP：通过索引取得少量数据
* OLAP：复杂查询，需要多表联接操作

### 5.6.2 联合索引

1. 联合索引：对多个列进行索引。

2. 好处：

    1. 对于查询SELECT * FROM TABLE WHERE a=XXX and b=XXX可以用（a,b)这个联合索引，也可以对SELECT * FROM TABLE WHERE a=XXX使用，但不能对SELECT * FROM TABLE WHERE b=XXX，因为b是无序的：
        1. <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201041939410.png" alt="image-20220104193957363" style="zoom:33%;" />

    2. 对第二个键值进行了排序处理，有时不需要额外的排序操作。

        1. e.g.  

            ```sql
            CREATE TABLE buy_log (
              	user_id INT UNSIGNED NOT NULL,
                buy_date DATE
            ) ENGINE=InnoDB
            
            INSERT INTO buy_log VALUES (1, '2009-01-01');
            INSERT INTO buy_log VALUES (2, '2009-01-01');
            INSERT INTO buy_log VALUES (3, '2009-01-01');
            INSERT INTO buy_log VALUES (1, '2009-02-01');
            INSERT INTO buy_log VALUES (3, '2009-02-01');
            INSERT INTO buy_log VALUES (1, '2009-03-01');
            INSERT INTO buy_log VALUES (1, '2009-04-01');
            
            ALTER TABLE buy_log ADD KEY (userid);
            ALTER TABLE buy_log ADD KEY(userid, buy_date);
            ```

            如果只对于userid进行查询，则优化器的选择有两个，单个的userid索引和（userid, buy_date) 联合索引，最终选择userid因为该索引的叶子结点<u>包含单个键值，所以一个页能存放更多的记录</u>。

        2. 接着如果要去除userid为1的近三次购买记录

            ```sql
            SELECT * FROM buy_log
            		WHERE userid=1 ORDER BY buy_date DESC LIMIT 3
            ```

            优化器也有两个可选，但这次选择了（userid, buy_date) 联合索引，因为这个联合索引中bu y_date已经排好序，无需再对buy_date进行额外排序操作。

        3. 如果强制使用userid，那么会使用一个排序才能完成查询。using filesort。

### 5.6.3 覆盖索引

1. 即从辅助索引中既可以得到查询记录，而不需要查询聚集索引中的记录。
2. 好处是不包含整行记录信息，其大小远小于聚集索引，减少IO操作。

### 5.6.4 优化器选择不使用索引的情况

1. 范围查找，JOIN连接情况下。（离散读取比较多的情况）

### 5.6.5 索引提示

1. 错误选择索引（很少发生）
2. 可选索引多，选择的时间开销大。

### 5.6.6 Multi-Range Read优化

1. 目的：减少磁盘随机访问，将随机方位转化为较为顺序的访问。
2. 工作方式：
    1. 将查询得到的辅助索引键值放入一个缓存（这时数据是根据辅助索引键值排序）
    2. 将缓存中的键值按照RowID排序
    3. 根据RowID顺序访问时记得数据文件
3. 如果缓冲池不够大，即不能放进去一张表的数据，频繁的操作会导致缓存中的页频繁被替换出，又被读进去。按照主键顺序可以减少此行为。
4. 将范围查询拆分为键值对，再拆分过程中过滤掉不符合查询条件的数据。

### 5.6.7 Index Condition Pushdown（ICP）优化

1. 将WHERE过滤放在存储引擎层，减少数据的索取，提高性能

## 5.7 哈希算法

### 5.7.1 哈希表

1. 直接寻址

    1. 问题：计算机容量限制

2. 哈希：根据函数算出槽位置

    1. 有可能碰撞
    2. 拉链法：放入链表

    <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201042012307.png" alt="image-20220104201208263" style="zoom:33%;" />

### 5.7.2 InnoDB中的哈希算法

1. 冲突机制：采用链表方式， 哈希函数采用除法散列（h(k) = h mod m）

### 5.7.3 自适应哈希索引

1. 数据库自己创建，DBA不干预

## 5.8 全文检索

### 5.8.1 概述

1. B+树可以通过索引字段的前缀查找，但是不能查找包含某一单词的查询。

    ```sql
    SELECT * FROM blog WHERE content like '%xxx%'
    ```

### 5.8.2 倒排索引

1. 全文检索的实现方式

2. 通过在辅助表存储单词和单词自身在一个或多个文档所在位置的映射。

    1. inverted file index

        <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201042022145.png" alt="image-20220104202230080" style="zoom:33%;" />

    2. full inverted index

        <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201042022396.png" alt="image-20220104202243354" style="zoom:33%;" />

### 5.8.3 InnoDB全文检索

1. innoDB采用full inverted index。
2. 信息放在辅助表（持久），存放在磁盘。另外还使用FTS index Cache（全文检索索引缓存（红黑树结构））提高性能。
    1. 辅助表是批量更新
3. FTS Document ID：**<u>与word进行映射</u>**。
4. 限制：
    1. 每张表只能有一个全文索引
    2. 多列组成的全文索引需要使用相同字符集和排序规则
    3. 不支持无单词界定符的语言

### 5.8.4 全文检索

MATCH... AGAINST...

#### 1. Natrual Language: 查询带有制定word的文档

#### 2. Boolean

#### 3. Query Expansion

## 5.9 小结

* 本章介绍了一些数据结构，全文索引。B+树索引和哈希索引，以及这些索引的使用和优化。

# 第六章 锁

## 6.1 什么是锁

1. 锁机制用于管理对**共享资源**的**并发访问**， 提供数据的完整性和一致性。

## 6.2 lock与latch

1. **<u>latch</u>**一般称为闩锁（轻量级锁），因为其要求锁定的时间必须非常短。又分为mutex互斥量和rwlock读写锁，保证并发**线程**操作临界资源的正确性，通常没有死锁检测的机制。
2. **<u>lock</u>**的对象是事务，用来锁定的是数据库中的对象（表、行、页）。被lock的对象仅在事务commit或rollback后进行释放。具有死锁机制。

## 6.3 InnoDB存储引擎中的锁

### 6.3.1 锁的类型

1. InnoDB实现了两种标准的行级锁：共享锁（S Lock）允许事务读一行数据，和排他锁（X Lock）允许事务删除或更新一行数据。

2. **锁兼容**：如果事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行的共享锁，因为读取没有改变r的数据。

3. 锁不兼容：如果事务T3想获得r的排他锁，则必须等待T1T2释放r的共享锁。

    <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201051557498.png" alt="image-20220105155708355" style="zoom:33%;" />

4. 多粒度锁定：支持表锁和行锁同时存在。

    1. 意向锁：将锁定的对象分为多个层次，意向锁意味着事务希望更细粒度上进行加锁。

        1. 意向共享锁（IS Lock）：事务想要获得一张表中某几行的共享锁

        2. 意向排他锁（IX Lock）：事务想要获得一张表中某几行的排他锁

            <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201051601896.png" alt="image-20220105160144859" style="zoom:33%;" />

### 6.3.2 一致性非锁定读

1. 指的是InnoDB通过行多版本控制，读取当前执行时间数据看中行的数据。如歌读取的行正在执行DELETE或UPDATE操作，这是读取操作不会因此去等待行上锁的释放，而去读取行的一个*快照*。

    <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201051606224.png" alt="image-20220105160647187" style="zoom:25%;" />

2. 该操作是通过undo段来完成。
3. 在READ COMMITTED和REPEATABLE READ（InnoDB默认事务隔离级别）下，存储引擎采用非锁定一致性读。
    1. 对快照的定义不同：
        1. READ COMMITED下， 总是读取最新的一份快照；
        2. REPEATABLE READ下，读取事务开始时的行数据版本。

### 6.3.3 一致性锁定读

1. 用户需要显式的对读取加锁：

    ```sql
    SELECT ... FOR UPDATE
    SELECT ... LOCK IN SHARE MODE
    ```

### 6.3.4 自增长与锁

1. AUTO-INC Locking：插入操作会依据自增长计数器值加1赋予自增长列。在完成对自增长值插入的SQL语句后立即释放。

### 6.3.5 外键和锁

1. 外键的插入和更新，首先查询父表的记录，即SELECT父表，对于父表的SELECT操作，使用SELECT ... LOCK IN SHARE MODE，加一个S锁。如果父表已经有X锁，子表的操作会被阻塞。

## 6.4 锁的算法

### 6.4.1 行锁的3种算法

1. Record Lock，单个记录上的锁。
2. Gap Lock：锁定一个范围不包括记录本身。
3. Next-key Lock：锁定一个范围+记录本身。为了解决幻读。如果索引具有唯一性，会降级为Record Lock。

### 6.4.2 解决幻读

## 6.5 锁问题

### 6.5.1 脏读

### 6.5.2 不可重复读

### 6.5.3丢失更新

## 6.6 阻塞

1. innoddb_lock_wait_timeout控制等待时间
2. innodb_rollback_on_timeout设定是否对等待超时的任务回滚，默认不回滚一般

## 6.7 死锁

### 6.7.1 死锁的概念

### 6.7.2 死锁的概率

### 6.7.3 死锁的示例

## 6.8 锁升级

1. 将当前的锁的粒度降低--一般是为了避免锁的开销
2. InnoDB不存在这个问题，因为他是根据事务而不是记录产生锁的，不管是一个事务锁住一个记录还是多个记录开销是一致的。

## 6.9 小结

介绍了锁以及它带来的问题。

# 第七章 事务

事务将数据库从一种抑制状态转为另一种一致状态。

## 7.1 认识事务

### 7.1.1 概述

1. 要么都做，要么不做
2. 满足ACID特性
3. InnoDB默认隔离级别为READ REPEATABLE
4. ACID
    1. A：原子性：整个数据库事务是不可分割的工作单位。
    2. C：一致性：事务将数据库从一种状态转变为下一种一致的状态。
    3. I：隔离性：要求每个读写事务的对象对其他事物的操作对象能互相分离。
    4. D：持久性：事务一旦提交，结果是永久性的。

### 7.1.2 分类

1. **扁平事务**：所有的操作处于同一层次，其间的操作是原子的。主要限制是不能提交或者回滚事务的某一部分，或分几个步骤提交。

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201111957971.png" alt="image-20220111195713706" style="zoom:25%;" />

2. **带有保存点的扁平事务**：除了支持扁平事务支持的操作，运行在事务执行过程中回到同一事务中较早的一个状态。

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201112001855.png" alt="image-20220111200150817" style="zoom:15%;" />

3. **链事务**：当系统崩溃时，保存点是易失的而非持久的。链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。
    1. 下一个事务的开始和当前事务的提交合并为一个操作，下一个事务将看到上一个事务的结果。
    2. 回滚仅限当前事务，COMMIT后释放当前事务的锁。
4. **嵌套事务**：层次框架结构。由顶层事务控制着各个层次的事务，子事务控制着局部变化。
    1. 子树可以是嵌套事务也可以是扁平事务。
    2. 也结点事务时扁平事务。跟到叶子距离可以不同。
    3. 子事务可以提交也可以回滚，但不会马上生效。子事务在顶层事务提交后才真正提交。
    4. 任意一个事务的回滚会引起子事务回滚，子事务仅保留ACI特性，没有D。

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201112008425.png" alt="image-20220111200831383" style="zoom:15%;" />

5. **分布式事务**：分布式环境下的扁平事务。

## 7.2 事务的实现

1. 隔离性由锁实现，原子性、一致性、持久性通过redo log和undo log实现。

### 7.2.1 redo

#### 1.基本概念

1. 重做日志实现事务的持久性。由重做日志缓冲（易失的）和重做日志文件（持久的）组成。
2. Force Log at Commit：当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的COMMIT操作完成才算完成。
3. 为了保证每次日志都写入redo log，每次重做日志写入重做日志文件后，innoDB都需要调用一次fsync操作。
    1. 重做日志缓冲先写入文件系统缓存，为了确保写入磁盘，必须进行次fsync，所以磁盘的性能决定了数据库性能。
4. 可以手动设置非持久性情况，提高性能。周期性的fsync而非每次提交，但也存在部分事务可能会被丢失的风险。
5. *binlog：MySQL层面产生的。

#### 2. log block

1. 重做日志文件、重做日志缓存都是以块的方式保存。称为重做日志块，大小为512字节。

    <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201112053269.png" alt="image-20220111205328198" style="zoom:15%;" />

#### 3. log group

1. 逻辑上的概念，由多个redo log file组成。
2. log buffer刷新内存中log block到磁盘的规则：
    1. 事务提交
    2. log buffer一半空间被使用
    3. log checkpoint时候

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201112059137.png" alt="image-20220111205908096" style="zoom:25%;" />

#### 4. 重做日志格式

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201112101797.png" alt="image-20220111210139754" style="zoom:35%;" />

#### 5. LSN

1. 日志序列号。占用8字节，单调递增。
2. 含义：重做日志写入总量‘check point位置；页的版本。

#### 6. 恢复

### 7.2.2 undo

#### 1. 基本概念

1. undo存放在数据库内部的一个特殊段（segment）中，称为undo段，位于共享表空间内。

2. 将数据库逻辑的恢复到原来的样子
3. 用户执行<u>ROLLBACK</u>时候，会将事务回滚，但是内存表的大小不会收缩。实际上他做的事与原来相反的操作。
4. undo的另一个作用是<u>MVCC</u>。当用户读取一行时，如该记录一件被另一事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读。
5. undo log会产生redo log，因为undo log也需要持久性的保护。

#### 2. undo存储管理

1. innodb有rollback segment，每个回滚段记录了1024个undo log segment，在每个undo log segment段中进行undo 页的申请。
2. 事务提交后不能马上删除undo log及他所在的页。因为其他事务可能徐涛通过undo log来得到行记录之前的版本。是否可以删除由purge线程判断。

#### 3. undo log格式

1. undo log 分为 insert undo log和update undo log。因为insert操作的记录支队事务本身可见，对其他事务不可见（隔离性）。该undo log可以在事务提交后直接删除，不需要进行purge操作。
2. update undo log

#### 4. 查看undo信息

### 7.2.3 purge

1. delete操作只是把记录的delete flag设置为1，记录没有被删除。真正的删除是在purge操作。
2. 因为innodb支持MVCC，记录不能在事务提交时立即进行处理。

### 7.2.4 group commit

1. 事务提交时会进行两个阶段的操作：

    1. 修改内存中事务对应的信息，并且将日志写入重做日志缓冲；
    2. 调用fsync将确保日志都从重做日志缓冲写入磁盘。

    步骤2相对步骤1慢，当有事务进行这个过程时，其他事务可以进行步骤1，完成步骤2后，大家使用1次fsync刷新到磁盘，减少磁盘压力。

## 7.3 事务控制语句



## 7.4 隐式提交的SQL语句

1. DDL语句
2. 用来隐式修改MySQL架构的操作
3. 管理语句

## 7.5 对于事务操作的统计

1. 事务处理能力 衡量 TPS：（rollback + commit）/ t

## 7.6 事务的隔离级别

1. SQL标准定义的四个隔离级别：READ UNCOMMITTED，READ COMMITTED，REPEATABLE READ，SERIALIZABLE
2. innoDB 默认REPEATABLE READ，并且使用next-key lock避免幻读，已经达到SQL标准的串行化。

## 7.7 分布式事务

### 7.7.1 MySQL数据库的分布式事务

1. 分布式事务使用两段式提交，第一阶段所有参与全局事务的阶段开始准备，告诉事务管理器他们准备好了。第二阶段事务管理器高速资源管理器执行rollback还是commit。如果任何一个节点不能提交，全部节点被告知回滚。

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202201162005841.png" alt="image-20220116200539759" style="zoom:23%;" />

### 7.7.2 内部XA事务

1. 存储引擎和插件之间或者存储引擎之间的分布式事务称为内部XA事务。e.g.binlog和innoDB存储引擎之间。

## 7.8 不好的事务习惯

### 7.8.1 在循环中提交

### 7.8.2 使用自动提交

### 7.8.3 使用自动回滚

## 7.9 长事务

1. 执行时间长的事务。

## 7.10小结

本章了解了什么事事务以及如何使用。事务遵循的ACID特性，进一步了解了实现原子性、隔离性的redo log和undo log。还了解了事务隔离级别。最后讨论如何正确的使用事务，最好的做法是把事务的START TRANSACTION、COMMIT、ROLLBACK交给程序完成，而非在存储过程内完成。

# 第八章 备份与恢复（Skip）

# 第九章性能调优（Skip）

# 第十章 InnoDB存储引擎源代码编译和调试（Skip）

