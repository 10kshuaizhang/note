# 第一章 MySQL体系结构和存储引擎

## 1.1 定义数据库和实例

1. **数据库**：物理操作系统文件和其他形式<u>文件</u>类型的<u>集合</u>
2. **实例**：MySQL数据由后台<u>线程</u>以及一个共享内存区组成。
    * 共享内存可以背运行的后台线程所共享
    * 数据库实例才是真正用于操作数据库文件的。
3. MySQL数据库实例在系统上的表现就是一个进程。

## 1.2 MySQL体系结构

1. MySQL由以下部分组成：
    1. 连接池组件
    2. 管理服务和工具组件
    3. SQL接口组件
    4. 查询分析器组件
    5. 优化器组件
    6. 缓冲组件
    7. 插件式存储引擎
    8. 物理文件
2. **插件式表存储引擎**：区别于其他数据库最重要的一个特点。
3. 存储引擎是基于表的。

## 1.3 MySQL存储引擎

### 1.3.1 InnoDB存储引擎

1. 特点：行锁支持，支持外键，支持非锁定读。
2. 高并发性通过多版本并发控制MVCC来获得，并实现了SQL 标准的4种隔离级别，<u>默认为REPEATABLE级别</u>。同时使用next-key locking的侧罗来避免幻读（phantom）的产生。
    1. 另外还提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能高可用的功能
3. 对于数据的存储，innoDB采用聚集的方式，因此每张表的存储都是按主键的顺序进行存放。
    * 如果没有显示定义主键，存储引擎会为每一行商城一个6字节的ROWID并以此作为主键。

### 1.3.2 MyISAM存储引擎

1. 特点：不支持事务、表锁设计，支持全文索引；缓冲池只缓存索引文件，而不缓冲数据文件。
2. myISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。

### 1.3.3 NDB存储引擎

1. 集群存储引擎，share nothing的集群架构。特点是数据全部放在内存，因此主键查找的速度极快。

### 1.3.4 Memory存储引擎

1. 将数据都放在内存中，适合存储临时数据表，以及数据仓库的维度表。默认使用哈希索引而非B+树索引。
2. 只支持表锁，并发性能差，不支持TEXT和BLOB类型；存储变长字段（varchar）是按照定长字段（char）进行的，因此会浪费内存。
3. 如果用它存放查询的中间结果，且结果大于表容量，则数据库会把它转换到MyISAM存储引擎表而存放到磁盘中，又myISAM不缓存数据文件，这时产生的临时表的性能对查询会有损失。

### 1.3.5 Archive存储引擎

1. 只支持INSERT和SELECT操作
2. 提供告诉的插入和压缩功能，适合存储归档数据。

### 1.3.6 Federated存储引擎

1. 不存放数据，指向一台远程MySQL数据库服务器上的表，类似透明网关。

### 1.3.7 Maria存储引擎

1. MyISAM后续版本替代，支持缓存数据和索引文件，应用了行锁设计，提供了MVCC，支持事务和非事务的选项，以及更好处理BLOB的性能。

### 1.3.8 其他存储引擎

## 1.4 存储引擎的比较（略）

## 1.5 连接MySQL

### 1.5.1 TCP/IP

### 1.5.2 命名管道和共享内存

### 1.5.3 UNIX域套接字

## 1.6 小结

本章介绍了数据库和数据库实例的定义，分析了MySQL数据库体系结构，进一步突出强调实例和数据库的区别。介绍了各种常见表存储引擎的特性、使用情况以及它们之间的区别。

# 第二章 InnoDB存储引擎

本章介绍InnoDB体系架构以及其特性。

## 2.1 InnoDB存储引擎概述

## 2.2 InnoDB存储引擎的版本

## 2.3 InnoDB体系架构

<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202112271745677.png" alt="image-20211227174547457" style="zoom:30%;" />

### 2.3.1 后台线程

1. **Master Thread**： 负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。
2. **IO Thread**： 处理异步IO请求的回调。
    * write，read，log， insert buffer IO Thread
3. **Purge Thread**：将提交的事务的undolog回收。
4. **Purge Cleaner Thread**：将之前版本中的脏页的刷新操作都放到单独的线程来完成。为了减轻原Master Thread的工作以及对于用户查询线程的阻塞。

### 2.3.3 内存

1. **缓冲池**

    1. 因为InnoDB是基于磁盘系统的，并将其中的记录按照页的方式进行管理，可将其视为基于磁盘的数据库系统。由于CPU速度和磁盘速度的鸿沟，通常使用缓冲池技术。
    2. 一块内存区域
        1. 读：先将磁盘读取到的页存放在缓冲池中，下次再读相同页时，先判断是否在缓冲池中，若在，则称命中，直接读取，否则读取磁盘中的页。
        2. 修改：首先修改缓冲池中的页，再以一定的频率刷新到磁盘上。通过一种叫**<u>checkpoint</u>**的机制刷新回磁盘。
    3. 缓冲池的大小影响着数据库的整体性能。
    4. InnoDB存储引擎内存结构
        1. <img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202112271817544.png" alt="image-20211227181733510" style="zoom:30%;" />

    5. 从InnoDB 1.0.x开始，允许有多个缓冲池实例，每个页根据哈希平均分配到不同的缓冲池实例中，减少数据库内部的资源竞争。

2. **LRU list、Free List和Flush List**

    1. 缓冲池是通过LRU算法管理的。
        1. InnoDB还有midpoint优化。新读取的页不放在首部而是放入到LRU列表的midpoint位置。默认位置为5/8处。
        2. 相比于朴素LRU算法：某些操作可能将缓冲池的页刷出，影响效率，例如索引或数据的扫描操作，需要访问表中的很多页，这些数据并非热点数据。
        3. 为了解决这个问题，还有一个参数innodb_old_blocks_time，用于表示读取到的mid位置后需要等待多久才会被加入到LRU的热端，如果在执行操作前用户觉得自己的热点数据不止某个值，可以在执行前通过设定此参数使数据尽量不被刷出。
        4. page made young：从old部分加入到new部分的操作。显示了LRU列表中页移动到前端的次数。
        5. LRU列表中的页被修改后成为脏页。
    2. FLUSH列表即为脏列表，脏页存在于FLUSH列表和LUR列表，但是互不影响。LRU列表管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘。

3. 重做日志缓冲：存储引擎现将redo log放在这个缓冲区，然后按照一定频率刷新到redo log 文件。

    1. 刷新时机
        1. Master Thread每一秒
        2. 每个事务提交时
        3. 当redo log缓冲池剩余空间小于一半

4. 额外的内存池

    1. 对内存的管理是通过内存堆。
    2. e.g.缓冲池的缓冲控制对象就是从额外的内存池申请。

## 2.4 checkpoint 技术

1. 为了避免发生数据丢失，当前事务数据库系统普遍采用Arite Ahead Log策略，即当事务提交时，先写重做日志，再修改页。当发生数据丢失时，通过redo log完成数据的恢复。这也是ACID中的D持久性的要求。

2. 如果

    1. 缓冲池可以缓存数据库中所有数据；
    2. 重做日志可以无限增大

    可以通过重做日志来恢复整个数据库中的数据到宕机发生的时刻。

3. **检查点Checkpoint**技术是解决：

    1. 缩短数据库恢复时间
        * 宕机发生时，数据库不需要重做所有的日志，因为checkpoint之前的页都已经刷新回磁盘。数据库只需要对checkpoint之后的重做日志进行恢复。
    2. 缓冲池不够用时，将脏页刷新到磁盘
        * 根据LRU算法算出的最近最少使用的页，如果是脏页，则需要强制执行checkpoint，将脏页刷回磁盘。
    3. 重做日志不可用时，刷新脏页。
        * 出现不可用是因为redo log被设计成重复使用，如果可能发生宕机系统恢复还需要这部分日志，则强制产生checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。

4. InnoDB是通过LSN标记版本的

5. checkpoint分类

    1. Sharp Checkpoint：数据库关闭时所有的脏页都刷新回磁盘。
    2. Fuzzy Checkpoint：只刷新一部分脏页。
        1. Master Thread Checkpoint：异步操作。
        2. FLUSH_LRU_LIST Checkpoint：存储引擎需要保证有100个空闲页可用，会将LRU列表尾部的页移除，如果存在脏页则需要进行checkpoint。
        3. Async/Sync Flush Checkpoint： 指的是重做日志不可用的情况。脏页是从脏页列表选取的。
            1. 在InnoDB 1.2.x版本开始，这部分操作放在了单独的page cleaner Thread中，不会阻塞用户查询线程。
        4. Dirty Page too much Checkpoint：保证缓冲池有足够可用的页。

## 2.5 Master Thread工作方式























