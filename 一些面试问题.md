来源 [帅地玩编程](https://www.cnblogs.com/kubidemanong/p/10734045.html)、JavaGuide，[MySQL问题](https://www.modb.pro/db/196560)

## MySQL

1. SQL为什么执行慢？

    1. 大多数情况正常，偶尔慢：

        * 数据库在刷新脏页，例如redo log写满了需要同步到磁盘。
        * 执行的时候，遇到锁。（可以用```show processlist```看当前状态）
        * SQL语句写的不好。

    2. 一直执行比较慢：

        ```sql
        mysql> CREATE TABLE `t` (
          `id` int(11) NOT NULL,
          `c` int(11) DEFAULT NULL,
          `d` int(11) DEFAULT NULL,
          PRIMARY KEY (`id`)
        ) ENGINE=InnoDB;
        ```

        1. 没有用上索引或者索引失效，e.g.该字段没有索引，或由于对字段进行运算、函数操作导致无法用索引。

            ```sql
            select * from t where 100 <c and c < 100000; # c无索引
            select * from t where c - 1 = 1000; # 对字段运算
            select * from t where pow(c,2) = 1000; # 对字段上函数
            ```

        2. 有索引可能会走全表扫描。

            1. e.g. 走 c 这个字段的索引的话，最后会查询到对应主键的值，然后，再根据主键的值走主键索引，查询到整行数据返回。 

                ```sql
                select * from t where 100 < c and c < 100000;
                ```

                系统在执行这条语句的时候，会进行预测：究竟是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？显然，扫描行数越少当然越好了，因为扫描行数越少，意味着I/O操作的次数越少。

                如果是扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，也就是说，需要走两次索引。而且，我们也不知道符合 100 c < and c < 10000 这个条件的数据有多少行，万一这个表是全部数据都符合呢？这个时候意味着，走 c 索引不仅扫描的行数是 n，同时还得每行数据走两次索引。

                **所以呢，系统是有可能走全表扫描而不走索引的。那系统是怎么判断呢？**

                判断来源于系统的预测，也就是说，如果要走 c 字段索引的话，系统会预测走 c 字段索引大概需要扫描多少行。如果预测到要扫描的行数很多，它可能就不走索引而直接扫描全表了。

                那么问题来了，**系统是怎么预测判断的呢？**索引区分度，称为基数，而数据量大时不可能全部扫描一遍得到基数，而采取抽样进行预测，有可能预测错了，认为技术很小，走了全表扫描。

            2. 不过呢，我们有时候也可以通过强制走索引的方式来查询，例如

                ```csharp
                select * from t force index(a) where c < 100 and c < 100000;
                ```

                我们也可以通过

                ```sql
                show index from t;
                ```

                来查询索引的基数和实际是否符合，如果和实际很不符合的话，我们可以重新来统计索引的基数，可以用这条命令

                ```css
                analyze table t;
                ```

                来重新统计分析。

                **既然会预测错索引的基数，这也意味着，当我们的查询语句有多个索引的时候，系统有可能也会选错索引哦**，这也可能是 SQL 执行的很慢的一个原因。

2. SQL优化（慢查询优化）

    1. 修改配置文件，在my.ini增加几行：慢查询的定义时间，以及慢查询的log日志
    2. 通过MySQL开启慢查询

3. 分析慢查询日志（explain分析执行计划）

    主要关注这几个字段即可：

    * **type**：表示MySQL在表中找到所需行的方式，或者叫访问类型

        - type=ALL，全表扫描，MySQL遍历全表来找到匹配行

        - type=index，索引全扫描

        - type=range，索引范围扫描

        - type=eq_ref，唯一索引

        - type=NULL，MySQL不用访问表或者索引，直接就能够得到结果（性能最好）

    * **possible_keys**: 表示查询可能使用的索引

    * **key**: 实际使用的索引

    * **key_len**: 使用索引字段的长度

    * **rows**: 扫描行的数量

    * **Extra**：

        - using index：覆盖索引，不回表

        - using where：回表查询

        - using filesort：需要额外的排序，不能通过索引得到排序结果

4. 慢sql如何优化

    面试从这几方面考虑：索引+sql语句+数据库结构优化+优化器优化+架构优化。

    1. 索引

    * 尽量覆盖索引
    * 组合索引符合最左匹配原则
    * 避免索引失效
    * 再写多读少的场景下，可以选择普通索引而不要唯一索引。更新时，普通索引可以使用change buffer进行优化，减少磁盘IO, 将更新操作记录到change bufer，等查询来了将数据读到内存再进行修改。
    * 索引建立原则（一般建在where和order by，基数要大，区分度要高，不要过度索引，外键建索引）

    2. SQL语句

        * 分页查询优化

            该方案适用于主键自增的表，可以把Limit查询转换成某个位置的查询。字查询优化分页查询：e.g. ```select * from tb_sku where id>20000 limit 10;```

        * 优化SELECT COUNT（*）

            * 实现行数统计，InnoDB需要便利，MyISAM因为存储了这个值直接用即可。
            * 如果经常用：
                * 用近似值代替，使用explain不会执行，而是返回近似值
                * 增加汇总统计：新增一个表

        * 优化SELECT *

            * MySQL 常用的存储引擎有 MyISAM 和 InnoDB，其中 InnoDB 在默认创建主键时会创建主键索引，而主键索引属于聚族索引，即在存储数据时，索引是基于 B + 树构成的，具体的行数据则存储在叶子节点。

                而 MyISAM 默认创建的主键索引、二级索引以及 InnoDB 的二级索引都属于非聚族索引，即在存储数据时，索引是基于 B + 树构成的，而叶子节点存储的是主键值。

                假设我们的订单表是基于 InnoDB 存储引擎创建的，且存在 order_no、status 两列组成的组合索引。此时，我们需要根据订单号查询一张订单表的 status，如果我们使用 select * from order where order_no='xxx’来查询，则先会查询组合索引，通过组合索引获取到主键 ID，再通过主键 ID 去主键索引中获取对应行所有列的值。

                如果我们使用 select order_no, status from order where order_no='xxx’来查询，则只会查询组合索引，通过组合索引获取到对应的 order_no 和 status 的值。

        * 优化insert语句

            - 多条插入语句写成一条

            - 在事务中插数据

            - 数据有序插入（主键索引）

    3. 数据库结构优化

        * 将字段多的表分解成多个表有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开。
        * 对于经常联合查询的表，可以考虑建立中间表。

    4. 优化器优化

        **1、优化器使用MRR**

        **原理**：MRR 【Multi-Range Read】将ID或键值读到buffer排序，通过把「随机磁盘读」，转化为「顺序磁盘读」，减少磁盘IO，从而提高了索引查询的性能。

        对于 Myisam，在去磁盘获取完整数据之前，会先按照 rowid 排好序，再去顺序的读取磁盘。

        对于 Innodb，则会按照聚簇索引键值排好序，再顺序的读取聚簇索引。

        **磁盘预读：**请求一页的数据时，可以把后面几页的数据也一起返回，放到数据缓冲池中，这样如果下次刚好需要下一页的数据，就不再需要到磁盘读取（局部性原理）

        **索引本身就是为了减少磁盘 IO，加快查询，而 MRR，则是把索引减少磁盘 IO 的作用，进一步放大**

        https://zhuanlan.zhihu.com/p/148680235

    5. 架构优化

        读/写分离（主库写，从库读）

    

    **总结**

    1、先设置慢查询（my.ini或数据库命令）

    2、分析慢查询日志

    3、定位低效率sql（show processlist）

    4、explain分析执行计划（是否索引失效，用到索引没，用了哪些）

    5、优化（索引+sql语句+数据库结构优化+优化器优化+架构优化）

## JVM

1. JVM内存划分

2. 详细介绍堆内存划分以及划分思路，为什么这样

    1. https://www.1024sou.com/article/17769.html

3. JVM调优

    1. 方式

        1. 记录日志 

        2. 对程序做好性能监控

        3. 根据日志和性能监控数据修改程序

        4. 使用专业工具通过不同的JVM参数进行压测并获得最佳配置

            <img src="https://pic3.zhimg.com/80/v2-6af2e83631defa904099e83b6b82bc86_1440w.jpg" alt="img" style="zoom:33%;" />

    2. 调优原则

        JVM的自动内存管理本来就是为了将开发人员从内存管理的泥潭里拉出来。即使不得不进行JVM调优，也绝对不能拍脑门就去调整参数，一定要全面监控，详细分析性能数据。

    3. JVM调优时机

        - Heap内存（老年代）持续上涨达到设置的最大内存值；
        - Full GC 次数频繁；
        - GC 停顿时间过长（超过1秒）；
        - 应用出现OutOfMemory 等内存异常；
        - 应用中有使用本地缓存且占用大量内存空间；
        - 系统吞吐量与响应性能不高或下降。

    4. 调优目标

        吞吐量、延迟、内存占用三者类似CAP，构成了一个不可能三角，只能选择其中两个进行调优，不可三者兼得。

        - 延迟：GC低停顿和GC低频率；
        - 低内存占用；
        - 高吞吐量;

    5. 例子

        https://zhuanlan.zhihu.com/p/363961261

4. 静态方法为什么不能调用非静态成员?

    1. 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
    2. 在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。