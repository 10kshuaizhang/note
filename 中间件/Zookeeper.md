# Zookeeper

- 什么是zookeeper
    - 分布式服务协调框架，实现同步服务，配置维护和命名服务等分布式应用。
    - 设计目标：将复杂且容易出错的分布式一致性服务封装，构成一个高效可靠的原语集（不可分割性），并以一系列简单易用的接口提供给用户使用。
- 重要概念
    - 一些重要概念
        - Zookeeper**本身就是一个分布式程序**（只要半数以上节存活，Zookeeper就能正常服务）。
        - 为了保证**高可用**，最好以集群形态部署Zookeeper，这样只要集群中大部分机器是可用的，那么Zk本身仍然是可用的。
        - Zoo keeper将数据保存在内存中，这也就保证了**高吞吐量和低延迟**（但是内存限制了能够存储的容量不大）
        - **Zookeeker底层只提供了两个功能：管理（存储、读取）用户程序提交的数据；为用户程序提交数据节点监听服务。**
    - 会话Session
        - Zookeeper中，一个客户端连接是指客户端和服务端之间的一个**TCP长连接**。
        - 通过这个连接，客户端能够通过**心跳检测**与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接收响应，同时还能够通过该连接接收来自服务器的Watch事件通知。
        - 当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在**sessionTimeout**规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。
            - Session的sessionTimeout值用来设置一个客户端会话的超时时间。
        - 分桶策略
            - 将类似的会话放在同一区块中进行管理，以便于Zookeeper对会话进行不同区块的隔离处理以及同一区块的统一处理。
        - 在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。
    - ZNode
        - 节点
            - 机器节点：指构成集群的机器
            - ZNode数据节点：指数据模型中的数据单元
                - **临时节点**
                    - 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。
                - **持久节点**
                    - 是指一旦这个ZNode被创建，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。
                - PERSISTENT*SEQUENTIAL-持久顺序节点*
                    - 基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。
                - EPHEMERAL*SEQUENTIAL-临时顺序节点*
                    - 基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。
    - 版本
        - 对应于每个ZNode，Zookeeper 都会为其维护一个叫作 Stat 的数据结构，Stat中记录了这个 ZNode 的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）和 cversion（当前ZNode的ACL版本）。
    - Watcher
        - Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的重要特性。
        - 特点
            - 一次性：无论是服务端还是客户端，一旦一个Watcher被触发，Zookeeper都会将其从相应的存储中移除。
            - 客户端串行执行：客户端Watcher回调的过程是一个串行同步的过程。
            - 轻量
                - Watcher通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。
                - 客户端向服务端注册Watcher的时候，并不会把客户端真实的Watcher对象实体传递到服务端，仅仅是在客户端请求中使用boolean类型属性进行了标记。
            - watcher event异步发送watcher的通知事件从server发送到client是异步的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于Zookeeper本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化。所以我们使用Zookeeper不能期望能够监控到节点每次的变化。Zookeeper只能保证最终的一致性，而无法保证强一致性。
            - 注册watcher getData、exists、getChildren
            - 触发watcher create、delete、setData
            - 当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch可能会丢失：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。
        - 客户端注册Watcher实现
            - 调用getData()/getChildren()/exist()三个API，传入Watcher对象
            - 标记请求request，封装Watcher到WatchRegistration
            - 封装成Packet对象，发服务端发送request
            - 收到服务端响应后，将Watcher注册到ZKWatcherManager中进行管理
            - 请求返回，完成注册。
        - 服务端处理Watcher实现
            - 服务端接收Watcher并存储
                - 接收到客户端请求，处理请求判断是否需要注册Watcher，需要的话将数据节点的节点路径和ServerCnxn（ServerCnxn代表一个客户端和服务端的连接，实现了Watcher的process接口，此时可以看成一个Watcher对象）存储在WatcherManager的WatchTable和watch2Paths中去。
            - Watcher触发
                - 以服务端接收到 setData() 事务请求触发NodeDataChanged事件为例：
            - 封装WatchedEvent
                - 将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路径封装成一个WatchedEvent对象
            - 查询Watcher
                - 从WatchTable中根据节点路径查找Watcher
                    - 没找到；说明没有客户端在该数据节点上注册过Watcher
                    - 找到；提取并从WatchTable和Watch2Paths中删除对应Watcher（从这里可以看出Watcher在服务端是一次性的，触发一次就失效了）
                - 调用process方法来触发Watcher
                    - 这里process主要就是通过ServerCnxn对应的TCP连接发送Watcher事件通知。
        - 客户端回调Watcher
            - 客户端SendThread线程接收事件通知，交由EventThread线程回调Watcher。客户端的Watcher机制同样是一次性的，一旦被触发后，该Watcher就失效了。
- ACL
    - Zookeeper采用ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。
        - 权限模式（Scheme）
            - IP：从IP地址粒度进行权限控制
            - Digest：最常用，用类似于 username:password 的权限标识来进行权限配置，便于区分不同应用来进行权限控制
            - World：最开放的权限控制方式，是一种特殊的digest模式，只有一个权限标识“world:anyone”
            - Super：超级用户
        - 授权对象
            - 授权对象指的是权限赋予的用户或一个指定实体，例如IP地址或是机器等。
        - 权限
            - CREATE：创建子节点
            - READ：获取节点数据和子节点列表的权限
            - WRITE：更新节点数据的权限
            - DELETE：删除子节点的权限
            - ADMIN：设计节点ACL的权限
    - Chroot特性
        - 3.2.0版本后，添加了 Chroot特性，该特性允许每个客户端为自己设置一个命名空间。如果一个客户端设置了Chroot，那么该客户端对服务器的任何操作，都将会被限制在其自己的命名空间下。
        - 通过设置Chroot，能够将一个客户端应用于Zookeeper服务端的一颗子树相对应，在那些多个应用共用一个Zookeeper进群的场景下，对实现不同应用间的相互隔离非常有帮助。
- Zookeeper特点
    - **顺序一致性**：从同一客户端发起的事务请求，最终会严格地按照顺序被应用到Zookeeper中去。
    - **原子性**：所有事务请求处理结果在整个集群中所有机器上的应用情况是一致的。要么整个集群中所有的机器都成功应用了某一个事务，要么都没有。
    - **单一系统映像**：无论客户端连到哪一个Zookeeper服务器上，看到的服务端数据模型都是一致的。
    - **可靠性**：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。
- Zookeeper设计目标
    - 简单的数据模型
        - ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似。 与为存储设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟。
    - 可构建集群
        - 为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么zookeeper本身仍然是可用的。
    - 顺序访问
        - 对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。 这个编号也叫做时间戳——zxid（Zookeeper Transaction Id）
    - 高性能
        - 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）
- Zookeeper集群角色介绍
    - Leader：ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器，Leader 既可以为客户端提供写服务又能提供读服务。
        - 事务请求的唯一调度和处理者，保证集群事务处理的顺序性
        - 集群内部各服务的调度者
    - Follower 
        - 处理客户端的非事务请求，转发事务请求给Leader服务器
        - 参与事务请求Proposal的投票
        - 参与Leader选举投票
    - Observer 旨在在不影响集群事务处理能力的基础上提升集群的非事务处理能力
        - 处理客户端的非事务请求，转发事务请求给Leader服务器
        - 不参与任何形式的投票
- Zookeeper 下 Server工作状态
    - LOOKING：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。
    - FOLLOWING：跟随者状态。表明当前服务器角色是Follower。
    - LEADING：领导者状态。表明当前服务器角色是Leader。
    - OBSERVING：观察者状态。表明当前服务器角色是Observer。
- Zookeeper & ZAB算法& Paxos算法
    - ZAB协议
        - 协议介绍
            - ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。
        - 两种基本模式
            - 崩溃恢复
                - 当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的Leader服务器。
                - 当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。
                    - 状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。
            - 消息广播
                - 当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。
                - 当一台同样遵守ZAB协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加人的服务器就会自觉地进人数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。
    - Paxos算法
- Zookeeper的典型应用场景
    - 数据发布/订阅
        - 介绍
            - 数据发布/订阅系统，即所谓的配置中心，顾名思义就是发布者发布数据供订阅者进行数据订阅。
        - 目的
            - 动态获取数据（配置信息）
            - 实现数据（配置信息）的集中式管理和数据的动态更新
        - 设计模式
            - Push 模式
            - Pull 模式
        - 数据（配置信息）特性
            - 数据量通常比较小
            - 数据内容在运行时会发生动态更新
            - 集群中各机器共享，配置一致，如：机器列表信息、运行时开关配置、数据库配置信息等
        - 基于Zookeeper的实现方式
            - 数据存储：将数据（配置信息）存储到Zookeeper上的一个数据节点
            - 数据获取：应用在启动初始化节点从Zookeeper数据节点读取数据，并在该节点上注册一个数据变更Watcher
            - 数据变更：当变更数据时，更新Zookeeper对应节点数据，Zookeeper会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即可。
    - 负载均衡
        - 使用Zookeeper实现负载均衡原理的演示。演示服务端和客户端通信。当只有一个服务端时，客户端把消息直接发给该服务端；当有多个服务端运行时（端口不同），客户端实现均衡地选择服务端来提供服务。客户端根据请求次数依次选择不同的服务端来连接，达到“负载均衡”的效果。服务端每次启动将服务注册到zk注册中心上，采用临时节点。客户端监听zk注册中心指定的路径，从zk节点上获取最新服务节点信息，模拟简单的负载均衡算法，轮流分配服务器。
    - 命名服务
        - 命名服务是指通过指定的名字来获取资源或者服务的地址，利用zk创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。
    - 分布式协调/通知
        - 程序分布式的部署在不同的机器上，将程序的配置信息放在zk的znode下，当有配置发生改变时，也就是znode发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。
    - 集群管理
        - 所谓集群管理无外乎两点：是否有机器退出和加入、选举master。对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。
    - Master选举
    - 分布式锁
        - 有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。
            - 对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute*lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute*lock 节点就释放出锁。
            - 对于第二类， /distribute*lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次获取。*
- 分布式队列
    - 两种类型的队列
        - 1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。
        - 2、队列按照 FIFO 方式进行入队和出队操作。和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建PERSISTENT*SEQUENTIAL节点，创建成功时Watcher通知等待的队列，队列删除序列号最小的节点用以消费。此场景下Zookeeper的znode用于消息存储，znode存储的数据就是消息队列中的消息内容，SEQUENTIAL序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。*





[https://juejin.cn/post/6844903677367418893#heading-13](https://juejin.cn/post/6844903677367418893#heading-13)

[https://juejin.cn/post/6844903608975114247#heading-0](https://juejin.cn/post/6844903608975114247#heading-0)

面试题：[https://cloud.tencent.com/developer/article/1513902](https://cloud.tencent.com/developer/article/1513902)
