1. 走近Java（略读）
2. Java内存区域与内存溢出异常
    1. 概述：Java不像C、C++一样需要手动去管理内存，但是因为如此，如果不了解JVM的内存管理机制，出问题的时候就会比较难定位；
    2. 运行时数据区域
        1. **程序计数器**：当前线程执行的字节码的行号指示器。
            1. 字节码解释器的工作就是通过改变这个计数器的值来选去下一条需要执行的指令，是程序**<u>控制流</u>**的指示器；
            2. 因为Java是jvm的多线程是勇敢多线程罗欢、分配处理器执行时间实现的，所以在一个时刻，一个处理器只会执行一条线程的指令；为了**<u>切换后能够恢复到正确的位置</u>**；每个线程都有一个独立的程序计数器，各个现场互不影响，独立存储，这类内存称为“**<u>线程私有</u>**”的内存。
            3. 如果正在执行Java方法，则PC中是他正在执行的虚拟机字节码指令的地址；如果是本地（native）方法，则PC为空
            4. 此内存区域是唯一一个**<u>没有OOM</u>**的区域
        2. **Java虚拟机栈**
            1. **<u>线程私有，生命周期和线程相同。</u>**
            2. 每个方法执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
            3. 人们粗糙的划分Java虚拟机内存为堆栈部分，这里的“栈”指的就是**<u>虚拟机栈，或者是其中的局部变量表部分</u>**；
            4. **局部变量表**存放了编译期可知的**<u>Java虚拟机基本数据类型、对象引用和return Address类型</u>**；
            5. 这些数据类型在局部变量表中以**<u>slot</u>**的来表示，其中double和long（64位）会占据两个槽，其余的1个；
            6. 内存空间在编译期进行分配，当进入一个方法时候，所需的内存空间是确定的，运行期间不会改变；
            7. 这个内存区域存在两类异常：1是因为线程请求的栈深度大雨虚拟机允许的深度，则StackOverFlowError；2是因为虚拟机栈容量动态扩展申请不到足够内存时候引起的OutOfMemoryError。
        3. **本地方法栈**
            1. 与Java虚拟机栈的作用类似，只不过他执行的是虚拟机使用到的本地方法；而虚拟机栈执行的是Java方法（也就是字节码）；
            2. ***本地方法***：简单地讲，**一个Native Method就是一个Java调用非Java代码的接囗**。该方法的实现由非Java语言实现，比如C。
                1. 为什么使用：在开发过程中，有些功能可能是使用C、C++实现的，有时候为了能够**复用这些功能**，就需要使用Native method；还有一点就是**操作系统底层的功能也需要使用本地方法去调用**；另外JVM自己的代码，有一部分使用C实现的，这些代码的使用也需要使用本地方法。
        4. **Java堆**
            1. 是所有线程共享的一块区域，在虚拟机启动时创建。不需要连续内存一般。
            2. **<u>唯一目的就是存放对象实例</u>**。
            3. 是垃圾收集器管理的区域，所以又叫GC堆；
            4. 如果在Java堆中没有完成实例分配并且堆也再无法扩展时，虚拟机会抛出oom。
        5. **方法区**
            1. 线程共享的区域，用来存储已经被虚拟机加载的类型信息、常量、静态变量、即使编译器编译后的代码缓存等数据。
            2. 如果方法区无法满足内存分配需求时，会抛出oom
        6. **运行时常量池**：是方法区的一部分
            1. 常量池表用于存放编译期生成的各种字面量和符号引用，这部分内容会在类加载后放到方法区
        7. **直接内存**
            1. 并非虚拟机运行时数据区一部分，只不过会被经常用到，而且作为内存也存在oom
    3. HotSpot虚拟机探秘
        1. 对象的创建
            1. **<u>类加载检查</u>**。首先去检查常量池中是否存在对应一个类的符号引用，并且是否已经被加载解析和初始化过；
            2. **<u>分配内存</u>**。
                1. 空间的划分分为两种，一种内存是规整的（即使用过的在一边，未使用过的在一边），则只需要一个指针就可以分配，因为内存的分配就是简单的指针的移动，这种叫**<u>指针碰撞</u>**；另一种是空间是交错的，虚拟机需要维护一个表来记录可用不可用的区域，分配的时候就在表中找一块足够大的区域分配，这种叫**<u>空闲列表</u>**。空间规整与否是由GC是否有**空间压缩整理**的的能力决定。
                2. 并发情况下，有两种方法避免线程不安全：
                    1. CAS + 失败重试保证原子性；
                    2. 在不同的空间中划分，TLAB
            3. **初始化**
                1. 如果使用了TLAB，会提前在这一步分配时进行；
                2. 这个操作保证了Java代码不需要赋初值就可以使用，访问其零值；
            4. **对象头的设置**
        2. 对象的内存布局
            1. 对象头：包含自身运行时的数据和类型指针（指向他类型原数据的指针）。
                1. 如果对象是一个数组，对象头还会保存一个记录数组长度的数据；
            2. 实例数据：对象真正存储的有效信息。
                1. 在HotSpot中，相同宽度的字段会分配到一起存放，父类的定义会出现在子类之前；
            3. 对齐填充，非必需，占位符作用。因为hotspot要起对象的起始地址是8的整数倍。
        3. 对象的访问定位
            1. Java程序会通过栈上的reference来操纵堆上的具体对象，但是方式由虚拟机决定；
            2. 有两种：
                1. **句柄**：Java堆中划分一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与数据类型各自具体的地址信息；
                2. **直接指针**：reference中存储的就是对象地址（Java堆中需要考虑如何防访问数据类型的相关信息），如果只是访问对象本身，就不需要一次间接访问的开销，快。HotSpot主要使用这种。