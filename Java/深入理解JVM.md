# 一、走近Java

## 1. 走近Java（略读）

# 二、自动内存管理

## 2. Java内存区域与内存溢出异常

1. 概述：Java不像C、C++一样需要手动去管理内存，但是因为如此，如果不了解JVM的内存管理机制，出问题的时候就会比较难定位；

2. 运行时数据区域
    1. **程序计数器**：当前线程执行的字节码的行号指示器。
        1. 字节码解释器的工作就是通过改变这个计数器的值来选去下一条需要执行的指令，是程序**<u>控制流</u>**的指示器；
        2. 因为Java是jvm的多线程是勇敢多线程罗欢、分配处理器执行时间实现的，所以在一个时刻，一个处理器只会执行一条线程的指令；为了**<u>切换后能够恢复到正确的位置</u>**；每个线程都有一个独立的程序计数器，各个现场互不影响，独立存储，这类内存称为“**<u>线程私有</u>**”的内存。
        3. 如果正在执行Java方法，则PC中是他正在执行的虚拟机字节码指令的地址；如果是本地（native）方法，则PC为空
        4. 此内存区域是唯一一个**<u>没有OOM</u>**的区域
    2. **Java虚拟机栈**
        1. **<u>线程私有，生命周期和线程相同。</u>**
        2. 每个方法执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
        3. 人们粗糙的划分Java虚拟机内存为堆栈部分，这里的“栈”指的就是**<u>虚拟机栈，或者是其中的局部变量表部分</u>**；
        4. **局部变量表**存放了编译期可知的**<u>Java虚拟机基本数据类型、对象引用和return Address类型</u>**；
        5. 这些数据类型在局部变量表中以**<u>slot</u>**的来表示，其中double和long（64位）会占据两个槽，其余的1个；
        6. 内存空间在编译期进行分配，当进入一个方法时候，所需的内存空间是确定的，运行期间不会改变；
        7. 这个内存区域存在两类异常：1是因为线程请求的栈深度大雨虚拟机允许的深度，则StackOverFlowError；2是因为虚拟机栈容量动态扩展申请不到足够内存时候引起的OutOfMemoryError。
    3. **本地方法栈**
        1. 与Java虚拟机栈的作用类似，只不过他执行的是虚拟机使用到的本地方法；而虚拟机栈执行的是Java方法（也就是字节码）；
        2. ***本地方法***：简单地讲，**一个Native Method就是一个Java调用非Java代码的接囗**。该方法的实现由非Java语言实现，比如C。
            1. 为什么使用：在开发过程中，有些功能可能是使用C、C++实现的，有时候为了能够**复用这些功能**，就需要使用Native method；还有一点就是**操作系统底层的功能也需要使用本地方法去调用**；另外JVM自己的代码，有一部分使用C实现的，这些代码的使用也需要使用本地方法。
    4. **Java堆**
        1. 是所有线程共享的一块区域，在虚拟机启动时创建。不需要连续内存一般。
        2. **<u>唯一目的就是存放对象实例</u>**。
        3. 是垃圾收集器管理的区域，所以又叫GC堆；
        4. 如果在Java堆中没有完成实例分配并且堆也再无法扩展时，虚拟机会抛出oom。
    5. **方法区**
        1. 线程共享的区域，用来存储已经被虚拟机加载的类型信息、常量、静态变量、即使编译器编译后的代码缓存等数据。
        2. 如果方法区无法满足内存分配需求时，会抛出oom
    6. **运行时常量池**：是方法区的一部分
        1. 常量池表用于存放编译期生成的各种字面量和符号引用，这部分内容会在类加载后放到方法区
    7. **直接内存**
        1. 并非虚拟机运行时数据区一部分，只不过会被经常用到，而且作为内存也存在oom
    
3. HotSpot虚拟机探秘
    1. 对象的创建
        1. **<u>类加载检查</u>**。首先去检查常量池中是否存在对应一个类的符号引用，并且是否已经被加载解析和初始化过；
        2. **<u>分配内存</u>**。
            1. 空间的划分分为两种，一种内存是规整的（即使用过的在一边，未使用过的在一边），则只需要一个指针就可以分配，因为内存的分配就是简单的指针的移动，这种叫**<u>指针碰撞</u>**；另一种是空间是交错的，虚拟机需要维护一个表来记录可用不可用的区域，分配的时候就在表中找一块足够大的区域分配，这种叫**<u>空闲列表</u>**。空间规整与否是由GC是否有**空间压缩整理**的的能力决定。
            2. 并发情况下，有两种方法避免线程不安全：
                1. CAS + 失败重试保证原子性；
                2. 在不同的空间中划分，TLAB
        3. **初始化**
            1. 如果使用了TLAB，会提前在这一步分配时进行；
            2. 这个操作保证了Java代码不需要赋初值就可以使用，访问其零值；
        4. **对象头的设置**
        
    2. 对象的内存布局
        1. **对象头**：包含自身运行时的数据和类型指针（指向他类型原数据的指针）。
            1. 如果对象是一个数组，对象头还会保存一个记录数组长度的数据；
        2. **实例数据**：对象真正存储的有效信息。
            1. 在HotSpot中，相同宽度的字段会分配到一起存放，父类的定义会出现在子类之前；
        3. 对齐填充，非必需，占位符作用。因为hotspot要起对象的起始地址是8的整数倍。
        
    3. 对象的访问定位
        1. Java程序会通过栈上的reference来操纵堆上的具体对象，但是方式由虚拟机决定；
        2. 有两种：
            1. **<u>句柄</u>**：Java堆中划分一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与数据类型各自具体的地址信息；
            2. **<u>直接</u>指针**：reference中存储的就是对象地址（Java堆中需要考虑如何防访问数据类型的相关信息），如果只是访问对象本身，就不需要一次间接访问的开销，快。HotSpot主要使用这种。
        
    4. 实战：OutOfMemoryError异常
    
        1. Java堆溢出
    
            1. ```java
                import java.util.ArrayList;
                import java.util.List;
                
                /**
                 * -verbose:gc -Xms20M -Xmx20M - XX:+HeapDumpOnOutOfMemoryError
                 */
                
                public class HeapOOM {
                    static class OOMObject {
                    }
                
                    public static void main(String[] args) {
                        List<OOMObject> list = new ArrayList<OOMObject>();
                
                        while (true) {
                            list.add(new OOMObject());
                        }
                    }
                }
                
                ```
                
            2. 出现这个区域的异常，常规处理方法是通过内存映像工具对Dump出来的堆转储快照进行分析
            
                1. 确认内存中导致OOM的对象是否是必要的，区分是出现了**<u>内存泄漏</u>**还是<u>**内存溢出**</u>：
                    1. 如果是泄漏，则可以通过工具查看GC Root引用链，看他的引用路径、和哪些GC Root关联，导致GC无法回收他们
                    2. 如果不是泄漏，即虚拟机中的对象都是必须存活的，那对应的Java虚拟机的参数设置看是否要调整，再从代码上看是否有一些对象生命周期过长，持有时间过长、存储结构设计不合理，减少程序运行期的内存消耗。
        
        2. 虚拟机栈和本地方法栈溢出
        
            1. ```java
                public class JavaVMStackSOF {
                    /**
                     * -Xss128k
                     */
                    private int stackLength = 1;
                    public void stackLeak() {
                        stackLength++;
                        stackLeak();
                    }
                
                    public static void main(String[] args) throws Throwable {
                        JavaVMStackSOF oom = new JavaVMStackSOF();
                        try {
                            oom.stackLeak();
                        } catch (Throwable e) {
                            System.out.println("stack length:" + oom.stackLength);
                            throw e;
                        }
                    }
                }
                ```
        
                结果：
        
                ```
                stack length:16608
                Exception in thread "main" java.lang.StackOverflowError
                	at JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:8)
                	at JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:8)
                	at JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:8)
                	...
                ```
        
            2. 对于不同的虚拟机和操作系统，栈容量最小值会有不同，这主要取决于操作系统内存分页大小。
        
            3. 无论是由于栈帧太大还是虚拟机容量太小，当新的栈内存无法分配，都是栈溢出错误，因为hotspot不允许动态扩展。
        
            4. 一般来说正常的方法调用，虚拟机的默认参数是够用的；但是如果在建立*<u>多线程</u>*出现栈内存溢出的时候，在不能减少内存书看或者更换64位虚拟机，只能是减少最大堆和减少栈容量来获取更多线程。
        
        3. 方法区和运行时常量池溢出
        
            1. JDK7之前，常量池分配在永久代中，JDK7及之后字符串常量池被移到Java堆中；
            2. JDK8之后，元空间替代永久代登场，HotSpot提供了一些参数：
                1. -XX: MaxMetaSize：设置最大值，默认-1即不限制，或者说只受限于本地内存大小
                2. MetaSpaceSize：初始空间大小
                3. MinMetaspaceFreeRation：控制最小元空间剩余容量，减少因为元空间不足导致的垃圾收集频率。
        
        4. 本机直接内存溢出
        
            1. 可通过-XX：MaxDirectMemorySize指定，如果不指定则与Java堆最大值默认一致；
        
            2. ```java
                import sun.misc.Unsafe;
                
                import java.lang.reflect.Field;
                
                /**
                 * -Xmx20M -XX:MaxDirectMemorySize=10M
                 */
                
                public class DirectMemoryOOM {
                    private static final int _1MB = 1024 * 1024;
                
                    public static void main(String[] args) throws Exception{
                        Field unsafeField = Unsafe.class.getDeclaredFields()[0];
                        unsafeField.setAccessible(true);
                        Unsafe unsafe = (Unsafe) unsafeField.get(null);
                        while (true) {
                            unsafe.allocateMemory(_1MB);
                        }
                    }
                }
                ```
        
            3. 由直接内存导致的栈溢出的明显特征就是HeapDump文件中不会看到明显的异常，如果**发现Dump文件很小，而程序中又使用了直接内存**，可以考虑查看这方面的原因。
        
        5. 小结：本章了解了虚拟机内存的划分以及哪部分区域、什么样的代码会导致内存溢出异常。下一章会讲解GC做了哪些努力来避免内存溢出。

## 3. 垃圾收集器与内存分配策略

1. 概述

    1. PC、虚拟机栈、本地方法随着线程而生而灭，每一个栈帧分配多少内存基本上是类结构确定下来时候就是已知的，因此这几个区域的内存分配和回收具备去订下，方法结束或者线程结束时， 内存自然就跟随着回收了；
    2. Java堆和方法区则有着很强的不确定性：一个借口的多个实现类需要的内存可能不一样，一个方法执行的不同分支需要的内存也不一样；

2. 对象已死？->垃圾回收前第一件事就是确认对象是否存活。

    1. **引用计数算法**：在对象中添加一个引用计数器，每当一个地方引用他，计数器加一，引用失效时，计数器减一，任何时刻计数器为零的对象就是不可能再被引用。

        1. 占用额外内存的空间，但是原理简单，**判定效率高**。

        2. Java没有使用因为有很多例外情况需要考虑（例如**<u>循环引用</u>**），需要大量的额外处理；

            1. ```java
                public class ReferenceCountingGC {
                    /**
                     * objA  和 objB会不会被GC呢？
                     */
                
                    public Object instance = null;
                
                    private static final int _1MB = 1024 * 1024;
                
                    // 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否回收过
                    private byte[] bigSize = new byte[2 * _1MB];
                
                    public static void main(String[] args) {
                        ReferenceCountingGC objA = new ReferenceCountingGC();
                        ReferenceCountingGC objB = new ReferenceCountingGC();
                        objA.instance = objB;
                        objB.instance = objA;
                
                        objA = null;
                        objB = null;
                
                        // 加上在这行发生GC， objA和objB会被回收吗？
                        System.gc();
                    }
                
                }
                ```

                结果：虚拟机正常执行GC，并没有因为他们互相引用就放弃回收，侧面说明Java不是使用reference counting算法。

    2. **可达性分析算法**：这个算法思路就是通过一系列成为“GC Roots”的根对象作为起始点集，从这些节点开始根据引用关系向下搜索，搜索过长所走过的路程称为“引用链”，如果某个对象到GC roots间没有任何引用链相连（从GC Roots到某个对象不可达），则证明此对象是不可能再被使用的。

        1. Java中可作为GC Roots的对象包括
            1. 虚拟机栈中引用的对象，例如正在运行的方法使用到的参数、局部变量、临时变量等；
            2. 方法区中类静态属性引用的对象；
            3. 方法区中常量引用的对象，比如常量池中的引用；
            4. 本地方法栈中JNI（即Native方法）引用的对象；
            5. 虚拟机内部的引用，如基本数据类型对应的Class对象一些常驻的异常等，还有系统类加载；
            6. 所有被同步锁持有的对象
            7. 反映Java虚拟机内部情况的JMXBean，JVMTI中注册的回调、本地代码缓存等。
            8. **<u>局部回收</u>**中堆的其他区域也有可能成为GC Roots

    3. 再谈引用

        1. 定义：传统定义：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就成该reference数据是代表某块内存、某个对象的引用。
            1. 强引用：传统的引用。
            2. 软引用：**有用但非必需**。在系统<u>将要发生内存溢出异常前</u>，才会把这些对象列进回收范围之中进行第二次回收。
            3. 弱引用：只能生存到下一次垃圾回收。
            4. 虚引用：一个对象是否有虚引用存在不会对其生存时间产生影响，也无法通过虚引用获得一个实例。他**<u>唯一的目的就是能在这个对象被回收的时候收到一个系统通知</u>**。

    4. 生存还是死亡？

        1. 即使是被判定为不可达，也不一定被GC。真正宣告一个对象死亡要经历两个标记过程；
            1. 可达性分析**<u>发现不可达</u>**之后标记一次；
            2. 再筛选对象是否需要执行**<u>```finalize()```</u>**方法。假如对象没有覆盖```finalize()```方法，或者这个方法已经被虚拟机调用过，虚拟机将这两种情况视为没必要执行。需要被执行的放入F-Queue中会被标记。
        2. 当他被判定需要执行```finalize()```方法，则该对象会被放入一个<u>**F-Queue**</u> 的队列，并在稍后会由一条虚拟机自动建立的、低调度优先级的Finalizer线程去执行他们的```finalize()```方法。
            1. 虚拟机会触发这个方法但不会等待他执行完毕，因为某个对象的finalize()方法执行缓慢会导致整个队列处于等待，甚至是整个回收子系统的崩溃。
            2. 对象如果在队列中被引用链中的对象关联即可逃脱被回收；
            3. 一个对象的finalize方法最多执行一次；

    5. 回收方法区

        1. 方法区回收条件苛刻，“性价比低”；
        2. 回收内容：废弃的常量和不再使用的类型。
        3. 废弃常量：
            1. 例如一个常量池中字面量回收。没有一个字符串对象引用，虚拟机中也没有方法引用，如果发生GC且垃圾收集器，这个字符串常量会被清理出常量池。
            2. 类型。
                1. 该类的实例都被回收
                2. 加载该类的类加载器被回收。
                3. 该类对应的java.lang.Class对象没有在任何地方被引用。
        4. 大量使用动态代理、反射、GCLib等字节码框架等**<u>频繁自定义类加载</u>**的场景中，都需要Java虚拟机具备**<u>类型卸载</u>**的能力来保证方法区没有过大的内存压力。

3. 垃圾收集算法

    1. 分代收集理论
        1. 建立在两个假说之上的经验法则：
            1. **弱分代假说：绝大多数对象都是朝生夕灭的；**
            2. **强分代假说：熬过越多次垃圾收集过程的对象就越难消亡；**

        2. 这两个分代假说奠定了**多款常用的GC的设计原则**：<u>收集器应该将java堆划分出不同的区域，然后将回收对象根据其年龄（熬过垃圾回收的次数）分配到不同的区域中存储</u>。
        3. 现代商用JVM至少分为：**<u>新生代</u>**和**<u>老年代</u>**。在新生代中，每次垃圾收集都会有大批对象死去，而每次回收后存活的少量对象将会逐步晋升到老年代中存放。
        4. <u>**Minor CG**</u>：只限于**新生代**中的收集。这个时候会有一些新生代被老年代引用，而了找出这些对象又需要在所有的老年代里面去遍历，这样会存在性能负担。
        5. 为了解决这个问题，又引入一个假说：**跨代引用假说**
            1. **跨代引用相对于同代引用来说仅占少数。**
            2. 新生代会建立一个全局数据结构：**记忆集**，把老年代分为若干小块，当Minor GC发生时。只有包含了跨代引用的小块内存会被加入到GC Roots进行扫描。

        6. **<u>部分收集</u>** <u>**Partial GC**</u>： 指目标不是完整手机整个Java堆的垃圾收集，其中又分为
            1. **<u>新生代收集（Minor GC/Young GC）</u>**：只限于**新生代**中的收集
            2. **<u>老年代收集（Major GC/Old GC）</u>**： 指目标只是老年代的垃圾收集。（只有CMS收集器会有单独手机老年代的行为）。
            3. 混合收集：指目标是收集整个新生代以及部分老年代的垃圾收集。（只有G1收集器会有这个行为）。

        7. **<u>整堆收集（Full GC）</u>**：收集整个Java堆和方法区的垃圾收集。

    2. **<u>标记-清除算法</u>**：首先标记出需要回收的对象，在标记完成后统一回收掉标记的对象；或者标记存活的对象，统一回收未被标记的对象。标记的过程就是是否是垃圾的判定过程。
        1. 缺点：1. 执行效率不稳定：如果Java堆存在大量的对象而且其中大量需要被回收，则会有大量的标记和清除动作，降低算法的执行效率；2. 内存空间的碎片化问题，导致后续较大对象存入找不到足够连续内存而再进行GC的动作。

    3. **<u>标记-复制算法</u>**：解决标记清除算法执行效率低的问题。具体内容是：按照可用内存容量分为大小相当的两块，每次只使用其中一块，这一块用完了就把还存活着的复制到另一块上去，再把已使用过的内存空间一次清理掉。
        1. 对于对数情况都是可回收到，这个算法只需要复制少量对象即可；运行高效；但是代价就是可用的内存缩小为原来一半。
        2. 更优化的**<u>“Apple”式回收</u>**：将内存分为Eden和两个Survivor，每次只使用eden和一个Survivor，垃圾收集时，将他们的内容复制到另一个Survivor上，清理掉已使用的Eden和Survivor上的内容；Eden和Survivor这两个区域的比例一般是8:1，即新生代中可用空间为90%总容量。
        3. 当存活对象超过10%，就需要依赖其他区域进行**分配担保**。->直接进入老年代。

    4. **<u>标记-整理算法</u>**：如果在老年代这种区域，大部分对象都会存活，标记复制就会效率低下。所以有了标记整理：标记过程和标记清除算法的前半部分一样，之后让所有存活对象向内存空间的一端移动，然后直接清理掉边界以外的内存。
        1. **移动式的回收算法**：风险1. 移动所有存活对象必须暂停整个程序；2. 如果不移动又有很多碎片可能，然后又要引入更复杂的机制来处理（内存分配器、内存处理器），增加额外的负担。
        2. 整体吞吐量（赋值器和收集器效率总和）来看，移动对象更划算。

    5. 还有一种和稀泥式的，多数时间是标记清除，碎片很影响对象分配了，标记整理一次。

4. HotSpot的算法细节实现（Skip）

5. 经典垃圾收集器（Skip）

6. 低延迟垃圾收集器（Skip）

7. 选择合适的垃圾收集器（Skip）

8. 实战：内存分配与回收策略

    1. 多数情况下，**<u>对象优先在Eden区分配</u>**，当Eden没有足够空间，JVM将进行一次Minor GC。
    2. **<u>大对象直接进入老年代</u>**。
    3. **<u>长期存活的对象将进入老年代。</u>**
    4. 动态对象年龄判定：如果年龄低于或等于某个年龄的对象总和大于Survivor容量的一半，则年龄大于或等于该年龄的对象直接进入老年区。
    5. 空间分配担保。在发生minor GC之前先看是否允许老年代空间担保失败，如果允许则看一下之前回收晋升到老年代的容量的平均值和老年代剩余容量对比，如果老年代不够存了，或者之前不允许担保失败，则进行Full GC。

9. 本章小结

    1. 介绍了**<u>垃圾收集算法</u>**，若干HotSpot中垃圾收集器，实例代码验证了Java虚拟机中**<u>自动内存分配和回收的主要规则</u>**。


## 4. 虚拟机性能监控、故障处理工具（Skip）

## 5. 调优案例分析与实战（Skip）

# 三、虚拟机执行子系统

## 6. 类文件结构

## 7. 虚拟机类加载机制

## 8. 虚拟机字节码执行引擎

## 9. 类加载于执行子系统的案例与实战（Skip）

# 四、程序编译与代码优化

## 10. 前端编译与优化（Skip）

## 11. 后端编译与优化（Skip）

# 五、高效并发

## 12. Java内存模型与线程

## 13. 线程安全与锁优化



