# 第二章 创建和销毁对象

## 1. 用静态工厂方法代替构造器

1. [静态工厂方法](https://www.liaoxuefeng.com/wiki/1252599548343744/1281319170474017)与构造器不同的第一大优势在于，它们有名称。

    名称可以突出方法的作用以及方法间的区别。

2. 不必在每次调用的时候都创建一个新对象。

    静态工厂方法能够为重复的调用返回相同对象，有助于类总能严格控制在某个时刻哪些实例应该存在。这种类被称为**实例受控的类**。

    	1. 确保是个singleton或者不可实例化的。
    	1. 使得不可变的值类可以确保不会存在两个相等的实例，即当且仅当a==b式，a.equals(b)才为true。

3. 它们可以返回原返回类型的任何子类型的对象。

    在选择返回对象的类时就有了更大的灵活性。

4. 所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。

5. 方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在。

6. 缺点：类如果不含公有的或者受保护的构造器，就不能被子类化。

7. 缺点2: 程序员很难发现它们。

## 2. 遇到多个构造器参数时要考虑使用构建器

静态工厂方法和构造器都有个共同的局限性：它们都不能很好的扩展到大量的可选参数。许多程序员会用重叠构造器模式，虽然可行，但是当有许多参数的时候，客户端代码会很难编写并且较难以阅读。

还有第二种代替办法：JavaBeans模式。在这种模式下先调用午餐构造函数创建对象，在调用setter方法设置每个必要参数，以及每个相关的可选参数。这种方法弥补了重叠构造器的不足，让创建实例变容易，但是缺点也很明显：在构造过程中JavaBean可能处于不一致的状态。另外，JavaBeans模式使得把类做成不可变的可能性不复存在，程序员需要额外做些事情来保障线程安全。

第三种方法：建造者模式。他不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器（或者静态工厂），得到一个Builder对象。然后客户端在builder对象上调用类似setter的方法，来设置每个相关的可选参数。最后，客户端调用无参的build方法来生成通常是不可变的对象。这个builder通常是他构建的类的静态成员类。

	1. builder模式模拟了具名的可选参数。
	1. 也适用于类层次结构。
	1. 不足在于为了创建对象，先要创建他的构造器，在性能注重的场合会是一个问题。